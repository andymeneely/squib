# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: false
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/matrix/all/matrix.rbi
#
# matrix-0.4.2

class Matrix
  def *(m); end
  def **(exp); end
  def +(m); end
  def +@; end
  def -(m); end
  def -@; end
  def /(other); end
  def ==(other); end
  def [](i, j); end
  def []=(i, j, v); end
  def abs; end
  def adjoint; end
  def adjugate; end
  def antisymmetric?; end
  def check_int(val, direction); end
  def check_range(val, direction); end
  def coerce(other); end
  def cofactor(row, column); end
  def cofactor_expansion(row: nil, column: nil); end
  def collect!(which = nil); end
  def collect(which = nil, &block); end
  def column(j); end
  def column_count; end
  def column_size; end
  def column_vectors; end
  def combine(*matrices, &block); end
  def component(i, j); end
  def conj; end
  def conjugate; end
  def det; end
  def det_e; end
  def determinant; end
  def determinant_bareiss; end
  def determinant_e; end
  def diagonal?; end
  def each(which = nil, &block); end
  def each_with_index(which = nil); end
  def eigen; end
  def eigensystem; end
  def element(i, j); end
  def elements_to_f; end
  def elements_to_i; end
  def elements_to_r; end
  def empty?; end
  def entrywise_product(m); end
  def eql?(other); end
  def find_index(*args); end
  def first_minor(row, column); end
  def freeze; end
  def hadamard_product(m); end
  def hash; end
  def hermitian?; end
  def hstack(*matrices); end
  def imag; end
  def imaginary; end
  def index(*args); end
  def initialize(rows, column_count = nil); end
  def initialize_copy(m); end
  def inspect; end
  def inv; end
  def inverse; end
  def inverse_from(src); end
  def laplace_expansion(row: nil, column: nil); end
  def lower_triangular?; end
  def lup; end
  def lup_decomposition; end
  def map!(which = nil); end
  def map(which = nil, &block); end
  def minor(*param); end
  def new_matrix(rows, column_count = nil); end
  def normal?; end
  def orthogonal?; end
  def permutation?; end
  def power_int(exp); end
  def rank; end
  def rank_e; end
  def real; end
  def real?; end
  def rect; end
  def rectangular; end
  def regular?; end
  def rotate_entries(rotation = nil); end
  def round(ndigits = nil); end
  def row(i, &block); end
  def row_count; end
  def row_size; end
  def row_vectors; end
  def rows; end
  def self.I(n); end
  def self.[](*rows); end
  def self.build(row_count, column_count = nil); end
  def self.column_vector(column); end
  def self.columns(columns); end
  def self.combine(*matrices); end
  def self.diagonal(*values); end
  def self.empty(row_count = nil, column_count = nil); end
  def self.hstack(x, *matrices); end
  def self.identity(n); end
  def self.new(*arg0); end
  def self.row_vector(row); end
  def self.rows(rows, copy = nil); end
  def self.scalar(n, value); end
  def self.unit(n); end
  def self.vstack(x, *matrices); end
  def self.zero(row_count, column_count = nil); end
  def set_col_range(row, col_range, value); end
  def set_column_vector(row_range, col, value); end
  def set_component(i, j, v); end
  def set_element(i, j, v); end
  def set_row_and_col_range(row_range, col_range, value); end
  def set_row_range(row_range, col, value); end
  def set_value(row, col, value); end
  def singular?; end
  def skew_symmetric?; end
  def square?; end
  def symmetric?; end
  def t; end
  def to_a; end
  def to_matrix; end
  def to_s; end
  def tr; end
  def trace; end
  def transpose; end
  def unitary?; end
  def upper_triangular?; end
  def vstack(*matrices); end
  def zero?; end
  extend Matrix::ConversionHelper
  include Enumerable
  include ExceptionForMatrix
  include Matrix::CoercionHelper
end
module ExceptionForMatrix
end
class ExceptionForMatrix::ErrDimensionMismatch < StandardError
  def initialize(val = nil); end
end
class ExceptionForMatrix::ErrNotRegular < StandardError
  def initialize(val = nil); end
end
class ExceptionForMatrix::ErrOperationNotDefined < StandardError
  def initialize(vals); end
end
class ExceptionForMatrix::ErrOperationNotImplemented < StandardError
  def initialize(vals); end
end
module Matrix::ConversionHelper
  def convert_to_array(obj, copy = nil); end
end
module Matrix::CoercionHelper
  def apply_through_coercion(obj, oper); end
  def self.check_int(val, count, kind); end
  def self.check_range(val, count, kind); end
  def self.coerce_to(obj, cls, meth); end
  def self.coerce_to_int(obj); end
  def self.coerce_to_matrix(obj); end
end
class Matrix::Scalar < Numeric
  def *(other); end
  def **(other); end
  def +(other); end
  def -(other); end
  def /(other); end
  def initialize(value); end
  include ExceptionForMatrix
  include Matrix::CoercionHelper
end
class Vector
  def *(x); end
  def +(v); end
  def +@; end
  def -(v); end
  def -@; end
  def /(x); end
  def ==(other); end
  def [](i); end
  def []=(i, v); end
  def angle_with(v); end
  def coerce(other); end
  def collect!(&block); end
  def collect(&block); end
  def collect2(v); end
  def component(i); end
  def covector; end
  def cross(*vs); end
  def cross_product(*vs); end
  def dot(v); end
  def each(&block); end
  def each2(v); end
  def element(i); end
  def elements; end
  def elements_to_f; end
  def elements_to_i; end
  def elements_to_r; end
  def eql?(other); end
  def freeze; end
  def hash; end
  def independent?(*vs); end
  def initialize(array); end
  def initialize_copy(v); end
  def inner_product(v); end
  def inspect; end
  def magnitude; end
  def map!(&block); end
  def map(&block); end
  def map2(v, &block); end
  def norm; end
  def normalize; end
  def r; end
  def round(ndigits = nil); end
  def self.[](*array); end
  def self.basis(size:, index:); end
  def self.elements(array, copy = nil); end
  def self.independent?(*vs); end
  def self.new(*arg0); end
  def self.zero(size); end
  def set_component(i, v); end
  def set_element(i, v); end
  def set_range(range, value); end
  def set_value(index, value); end
  def size; end
  def to_a; end
  def to_matrix; end
  def to_s; end
  def zero?; end
  extend Matrix::ConversionHelper
  include Enumerable
  include ExceptionForMatrix
  include Matrix::CoercionHelper
end
class Vector::ZeroVectorError < StandardError
end
