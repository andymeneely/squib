# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strict
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/notiffany/all/notiffany.rbi
#
# notiffany-0.1.3

module Notiffany
  def self.connect(options = nil); end
end
class Notiffany::Notifier
  def _activate; end
  def _check_server!; end
  def _client?; end
  def _detect_or_add_notifiers; end
  def _env; end
  def _notification_wanted?; end
  def _turn_on_notifiers(options); end
  def active?; end
  def available; end
  def config; end
  def disconnect; end
  def enabled?; end
  def initialize(opts); end
  def notify(message, message_opts = nil); end
  def turn_off; end
  def turn_on(options = nil); end
end
class Notiffany::Notifier::Base
  def _check_available(_options); end
  def _check_host_supported; end
  def _gem_name; end
  def _image_path(image); end
  def _notification_type(image); end
  def _notify_options(overrides = nil); end
  def _perform_notify(_message, _opts); end
  def _require_gem; end
  def _supported_hosts; end
  def initialize(opts = nil); end
  def name; end
  def notify(message, opts = nil); end
  def options; end
  def title; end
end
class Notiffany::Notifier::Base::UnavailableError < RuntimeError
  def initialize(reason); end
  def message; end
end
class Notiffany::Notifier::Base::RequireFailed < Notiffany::Notifier::Base::UnavailableError
  def initialize(gem_name); end
end
class Notiffany::Notifier::Base::UnsupportedPlatform < Notiffany::Notifier::Base::UnavailableError
  def initialize; end
end
class Notiffany::Notifier::Emacs < Notiffany::Notifier::Base
  def _check_available(options); end
  def _emacs_color(type, options = nil); end
  def _erb_for(filename); end
  def _gem_name; end
  def _perform_notify(message, opts = nil); end
end
class Notiffany::Notifier::Emacs::Client
  def _emacs_eval(env, code); end
  def available?; end
  def elisp_erb; end
  def initialize(options); end
  def notify(color, bgcolor, message = nil); end
end
class Notiffany::Notifier::Emacs::Client::Elisp < ERB
  def bgcolor; end
  def color; end
  def initialize(code, color, bgcolor, message); end
  def message; end
  def result; end
end
class Notiffany::Notifier::File < Notiffany::Notifier::Base
  def _check_available(opts = nil); end
  def _gem_name; end
  def _perform_notify(message, opts = nil); end
end
class Notiffany::Notifier::GNTP < Notiffany::Notifier::Base
  def _check_available(_opts); end
  def _gem_name; end
  def _gntp_client(opts = nil); end
  def _perform_notify(message, opts = nil); end
  def _supported_hosts; end
end
class Notiffany::Notifier::Growl < Notiffany::Notifier::Base
  def _check_available(_opts = nil); end
  def _perform_notify(message, opts = nil); end
  def _supported_hosts; end
end
class Notiffany::Notifier::Libnotify < Notiffany::Notifier::Base
  def _check_available(_opts = nil); end
  def _perform_notify(message, opts = nil); end
  def _supported_hosts; end
end
class Notiffany::Notifier::NotifySend < Notiffany::Notifier::Base
  def _check_available(_opts = nil); end
  def _gem_name; end
  def _notifysend_urgency(type); end
  def _perform_notify(message, opts = nil); end
  def _supported_hosts; end
  def _to_arguments(command, supported, opts = nil); end
end
class Notiffany::Notifier::Notifu < Notiffany::Notifier::Base
  def _check_available(_opts = nil); end
  def _gem_name; end
  def _notifu_type(type); end
  def _perform_notify(message, opts = nil); end
  def _supported_hosts; end
end
class Notiffany::Notifier::TerminalNotifier < Notiffany::Notifier::Base
  def _check_available(_opts = nil); end
  def _gem_name; end
  def _perform_notify(message, opts = nil); end
  def _supported_hosts; end
end
class Notiffany::Notifier::TerminalTitle < Notiffany::Notifier::Base
  def _check_available(_options); end
  def _gem_name; end
  def _perform_notify(message, opts = nil); end
  def turn_off; end
end
class Notiffany::Notifier::Tmux < Notiffany::Notifier::Base
  def _check_available(opts = nil); end
  def _gem_name; end
  def _perform_notify(message, options = nil); end
  def self._end_session; end
  def self._session; end
  def self._start_session; end
  def turn_off; end
  def turn_on; end
end
class Notiffany::Notifier::Tmux::Client
  def _all_args_for(key, value, client); end
  def _capture(*args); end
  def _parse_option(line); end
  def _run(*args); end
  def clients; end
  def display_message(message); end
  def display_time=(time); end
  def initialize(client); end
  def message_bg=(color); end
  def message_fg=(color); end
  def parse_options; end
  def self._capture(*args); end
  def self._run(*args); end
  def self.version; end
  def set(key, value); end
  def title=(string); end
  def unset(key, value); end
end
class Notiffany::Notifier::Tmux::Session
  def close; end
  def initialize; end
end
class Notiffany::Notifier::Tmux::Notification
  def _message_for(title, message); end
  def _value_for(field); end
  def client; end
  def color; end
  def colorize(locations); end
  def display_message(title, message); end
  def display_title(title, message); end
  def initialize(type, options); end
  def message_color; end
  def options; end
  def separator; end
  def type; end
end
class Notiffany::Notifier::Tmux::Error < RuntimeError
end
class Notiffany::Notifier::YamlEnvStorage < Nenv::Environment
  def notifiers; end
  def notifiers=(raw_value); end
end
class Notiffany::Notifier::Detected
  def _add(name, opts); end
  def _notifiers; end
  def _to_module(name); end
  def add(name, opts); end
  def available; end
  def detect; end
  def initialize(supported, env_namespace, logger); end
  def reset; end
end
class Notiffany::Notifier::Detected::NoneAvailableError < RuntimeError
end
class Notiffany::Notifier::Detected::UnknownNotifier < RuntimeError
  def initialize(name); end
  def message; end
  def name; end
end
class Notiffany::Notifier::Config
  def _setup_logger(opts); end
  def env_namespace; end
  def initialize(opts); end
  def logger; end
  def notifiers; end
  def notify?; end
end
class Notiffany::Notifier::Env < Nenv::Environment
  def notify?; end
  def notify_active=(raw_value); end
  def notify_active?; end
  def notify_pid; end
  def notify_pid=(raw_value); end
end
class Notiffany::Notifier::NotServer < RuntimeError
end
