# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strict
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/gio2/all/gio2.rbi
#
# gio2-3.4.9

module Gio
  def self.action_name_is_valid?(*arguments, &block); end
  def self.action_parse_detailed_name(*arguments, &block); end
  def self.action_print_detailed_name(*arguments, &block); end
  def self.app_info_create_from_commandline(*arguments, &block); end
  def self.app_info_get_all(*arguments, &block); end
  def self.app_info_get_all_for_type(*arguments, &block); end
  def self.app_info_get_default_for_type(*arguments, &block); end
  def self.app_info_get_default_for_uri_scheme(*arguments, &block); end
  def self.app_info_get_fallback_for_type(*arguments, &block); end
  def self.app_info_get_recommended_for_type(*arguments, &block); end
  def self.app_info_launch_default_for_uri(*arguments, &block); end
  def self.app_info_launch_default_for_uri_async(*arguments, &block); end
  def self.app_info_launch_default_for_uri_finish(*arguments, &block); end
  def self.app_info_reset_type_associations(*arguments, &block); end
  def self.async_initable_newv_async(*arguments, &block); end
  def self.bus_get(*arguments, &block); end
  def self.bus_get_finish(*arguments, &block); end
  def self.bus_get_sync(*arguments, &block); end
  def self.bus_own_name(*arguments, &block); end
  def self.bus_own_name_on_connection(*arguments, &block); end
  def self.bus_unown_name(*arguments, &block); end
  def self.bus_unwatch_name(*arguments, &block); end
  def self.bus_watch_name(*arguments, &block); end
  def self.bus_watch_name_on_connection(*arguments, &block); end
  def self.dtls_client_connection_new(*arguments, &block); end
  def self.dtls_server_connection_new(*arguments, &block); end
  def self.file_new_for_commandline_arg(*arguments, &block); end
  def self.file_new_for_commandline_arg_and_cwd(*arguments, &block); end
  def self.file_new_for_path(*arguments, &block); end
  def self.file_new_for_uri(*arguments, &block); end
  def self.file_new_tmp(*arguments, &block); end
  def self.file_parse_name(*arguments, &block); end
  def self.icon_deserialize(*arguments, &block); end
  def self.icon_hash(*arguments, &block); end
  def self.icon_new_for_string(*arguments, &block); end
  def self.initable_newv(*arguments, &block); end
  def self.io_error_from_errno(*arguments, &block); end
  def self.io_error_quark(*arguments, &block); end
  def self.io_extension_point_implement(*arguments, &block); end
  def self.io_extension_point_lookup(*arguments, &block); end
  def self.io_extension_point_register(*arguments, &block); end
  def self.io_modules_load_all_in_directory(*arguments, &block); end
  def self.io_modules_load_all_in_directory_with_scope(*arguments, &block); end
  def self.io_modules_scan_all_in_directory(*arguments, &block); end
  def self.io_modules_scan_all_in_directory_with_scope(*arguments, &block); end
  def self.io_scheduler_cancel_all_jobs(*arguments, &block); end
  def self.io_scheduler_push_job(*arguments, &block); end
  def self.keyfile_settings_backend_new(*arguments, &block); end
  def self.memory_settings_backend_new(*arguments, &block); end
  def self.network_monitor_get_default(*arguments, &block); end
  def self.networking_init(*arguments, &block); end
  def self.null_settings_backend_new(*arguments, &block); end
  def self.pollable_source_new(*arguments, &block); end
  def self.pollable_source_new_full(*arguments, &block); end
  def self.pollable_stream_read(*arguments, &block); end
  def self.pollable_stream_write(*arguments, &block); end
  def self.pollable_stream_write_all(*arguments, &block); end
  def self.proxy_get_default_for_protocol(*arguments, &block); end
  def self.proxy_resolver_get_default(*arguments, &block); end
  def self.resolver_error_quark(*arguments, &block); end
  def self.resource_error_quark(*arguments, &block); end
  def self.resource_load(*arguments, &block); end
  def self.settings_schema_source_get_default(*arguments, &block); end
  def self.simple_async_report_gerror_in_idle(*arguments, &block); end
  def self.tls_backend_get_default(*arguments, &block); end
  def self.tls_client_connection_new(*arguments, &block); end
  def self.tls_error_quark(*arguments, &block); end
  def self.tls_file_database_new(*arguments, &block); end
  def self.tls_server_connection_new(*arguments, &block); end
  def self.unix_is_mount_path_system_internal?(*arguments, &block); end
  def self.unix_is_system_device_path?(*arguments, &block); end
  def self.unix_is_system_fs_type?(*arguments, &block); end
  def self.unix_mount_at(*arguments, &block); end
  def self.unix_mount_compare(*arguments, &block); end
  def self.unix_mount_copy(*arguments, &block); end
  def self.unix_mount_for(*arguments, &block); end
  def self.unix_mount_free(*arguments, &block); end
  def self.unix_mount_get_device_path(*arguments, &block); end
  def self.unix_mount_get_fs_type(*arguments, &block); end
  def self.unix_mount_get_mount_path(*arguments, &block); end
  def self.unix_mount_guess_can_eject(*arguments, &block); end
  def self.unix_mount_guess_icon(*arguments, &block); end
  def self.unix_mount_guess_name(*arguments, &block); end
  def self.unix_mount_guess_should_display(*arguments, &block); end
  def self.unix_mount_guess_symbolic_icon(*arguments, &block); end
  def self.unix_mount_is_readonly?(*arguments, &block); end
  def self.unix_mount_is_system_internal?(*arguments, &block); end
  def self.unix_mount_points_changed_since(*arguments, &block); end
  def self.unix_mount_points_get(*arguments, &block); end
  def self.unix_mounts_changed_since(*arguments, &block); end
  def self.unix_mounts_get(*arguments, &block); end
end
class Gio::Loader < GObjectIntrospection::Loader
  def define_content_type_class; end
  def define_dbus_module; end
  def define_mime_type_class; end
  def define_resources_module; end
  def error_parent_class(info); end
  def load_function_info(info); end
  def load_function_info_content_type(info); end
  def load_function_info_singleton_method(info, klass, method_name); end
  def post_load(repository, namespace); end
  def pre_load(repository, namespace); end
  def require_extension; end
  def require_libraries; end
  def rubyish_class_name(info); end
  def should_unlock_gvl?(function_info, klass); end
end
module Gio::PollableSource
  def set_callback; end
end
module Gio::Action
  def activate(parameter = nil); end
  def activate_raw(*arguments, &block); end
  def change_state(*arguments, &block); end
  def enabled?(*arguments, &block); end
  def name(*arguments, &block); end
  def parameter_type(*arguments, &block); end
  def self.name_is_valid?(*arguments, &block); end
  def self.parse_detailed_name(*arguments, &block); end
  def self.print_detailed_name(*arguments, &block); end
  def state(*arguments, &block); end
  def state_hint(*arguments, &block); end
  def state_type(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
module Gio::ActionMap
  def actions; end
  def add_action(action); end
  def add_action_entries(*arguments, &block); end
  def add_action_raw(*arguments, &block); end
  def add_actions(actions); end
  def convert_to_action(definition); end
  def lookup_action(*arguments, &block); end
  def remove_action(name); end
  def remove_action_raw(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::ApplicationCommandLine < GLib::Object
  def arguments(*arguments, &block); end
  def create_file_for_arg(*arguments, &block); end
  def cwd(*arguments, &block); end
  def environ(*arguments, &block); end
  def exit_status(*arguments, &block); end
  def exit_status=(*arguments, &block); end
  def getenv(*arguments, &block); end
  def initialize(properties = nil); end
  def options_dict(*arguments, &block); end
  def parent_instance; end
  def platform_data(*arguments, &block); end
  def priv; end
  def remote?(*arguments, &block); end
  def set_exit_status(*arguments, &block); end
  def stdin(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::ContentType
  def ==(other); end
  def a?; end
  def description; end
  def executable?; end
  def generic_icon_name; end
  def icon; end
  def initialize(type); end
  def mime_type; end
  def mime_type?; end
  def self.guess(*arguments, &block); end
  def self.registered; end
  def self.registered_raw(*arguments, &block); end
  def symbolic_icon; end
  def to_s; end
  def unknown?; end
end
module Gio::File
  def ==(*arguments, &block); end
  def append_to(*arguments, &block); end
  def append_to_async(*arguments, &block); end
  def append_to_finish(*arguments, &block); end
  def attributes_finish=(*arguments, &block); end
  def basename(*arguments, &block); end
  def copy(*arguments, &block); end
  def copy_async(*arguments, &block); end
  def copy_attributes(*arguments, &block); end
  def copy_finish(*arguments, &block); end
  def create(*arguments, &block); end
  def create_async(*arguments, &block); end
  def create_finish(*arguments, &block); end
  def create_readwrite(*arguments, &block); end
  def create_readwrite_async(*arguments, &block); end
  def create_readwrite_finish(*arguments, &block); end
  def delete(*arguments, &block); end
  def delete_async(*arguments, &block); end
  def delete_finish(*arguments, &block); end
  def display_name_finish=(*arguments, &block); end
  def dup(*arguments, &block); end
  def eject_mountable(*arguments, &block); end
  def eject_mountable_finish(*arguments, &block); end
  def eject_mountable_with_operation(*arguments, &block); end
  def eject_mountable_with_operation_finish(*arguments, &block); end
  def enumerate_children(*arguments, &block); end
  def enumerate_children_async(*arguments, &block); end
  def enumerate_children_finish(*arguments, &block); end
  def find_enclosing_mount(*arguments, &block); end
  def find_enclosing_mount_async(*arguments, &block); end
  def find_enclosing_mount_finish(*arguments, &block); end
  def get_child(*arguments, &block); end
  def get_child_for_display_name(*arguments, &block); end
  def get_relative_path(*arguments, &block); end
  def guess_content_types; end
  def has_parent?(*arguments, &block); end
  def has_prefix?(*arguments, &block); end
  def has_uri_scheme?(*arguments, &block); end
  def hash(*arguments, &block); end
  def load_bytes(*arguments, &block); end
  def load_bytes_async(*arguments, &block); end
  def load_bytes_finish(*arguments, &block); end
  def load_contents(*arguments, &block); end
  def load_contents_async(*arguments, &block); end
  def load_contents_finish(*arguments, &block); end
  def load_partial_contents_finish(*arguments, &block); end
  def make_directory(*arguments, &block); end
  def make_directory_async(*arguments, &block); end
  def make_directory_finish(*arguments, &block); end
  def make_directory_with_parents(*arguments, &block); end
  def make_symbolic_link(*arguments, &block); end
  def measure_disk_usage_finish(*arguments, &block); end
  def monitor(*arguments, &block); end
  def monitor_directory(*arguments, &block); end
  def monitor_file(*arguments, &block); end
  def mount_enclosing_volume(*arguments, &block); end
  def mount_enclosing_volume_finish(*arguments, &block); end
  def mount_mountable(*arguments, &block); end
  def mount_mountable_finish(*arguments, &block); end
  def move(*arguments, &block); end
  def native?(*arguments, &block); end
  def open_readwrite(*arguments, &block); end
  def open_readwrite_async(*arguments, &block); end
  def open_readwrite_finish(*arguments, &block); end
  def parent(*arguments, &block); end
  def parse_name(*arguments, &block); end
  def path(*arguments, &block); end
  def peek_path(*arguments, &block); end
  def poll_mountable(*arguments, &block); end
  def poll_mountable_finish(*arguments, &block); end
  def query_default_handler(*arguments, &block); end
  def query_exists(*arguments, &block); end
  def query_file_type(*arguments, &block); end
  def query_filesystem_info(*arguments, &block); end
  def query_filesystem_info_async(*arguments, &block); end
  def query_filesystem_info_finish(*arguments, &block); end
  def query_info(*arguments, &block); end
  def query_info_async(*arguments, &block); end
  def query_info_finish(*arguments, &block); end
  def query_settable_attributes(*arguments, &block); end
  def query_writable_namespaces(*arguments, &block); end
  def read(cancellable = nil); end
  def read_async(*arguments, &block); end
  def read_finish(*arguments, &block); end
  def read_raw(*arguments, &block); end
  def replace(*arguments, &block); end
  def replace_async(*arguments, &block); end
  def replace_contents(*arguments, &block); end
  def replace_contents_async(*arguments, &block); end
  def replace_contents_bytes_async(*arguments, &block); end
  def replace_contents_finish(*arguments, &block); end
  def replace_finish(*arguments, &block); end
  def replace_readwrite(*arguments, &block); end
  def replace_readwrite_async(*arguments, &block); end
  def replace_readwrite_finish(*arguments, &block); end
  def resolve_relative_path(*arguments, &block); end
  def self.commandline_arg(*margs, &mblock); end
  def self.new_for_commandline_arg(*arguments, &block); end
  def self.new_for_commandline_arg_and_cwd(*arguments, &block); end
  def self.new_for_path(*arguments, &block); end
  def self.new_for_uri(*arguments, &block); end
  def self.new_tmp(*arguments, &block); end
  def self.open(options = nil); end
  def self.parse_name(*arguments, &block); end
  def self.path(*margs, &mblock); end
  def self.uri(*margs, &mblock); end
  def set_attribute(*arguments, &block); end
  def set_attribute_byte_string(*arguments, &block); end
  def set_attribute_int32(*arguments, &block); end
  def set_attribute_int64(*arguments, &block); end
  def set_attribute_string(*arguments, &block); end
  def set_attribute_uint32(*arguments, &block); end
  def set_attribute_uint64(*arguments, &block); end
  def set_attributes_async(*arguments, &block); end
  def set_attributes_finish(*arguments, &block); end
  def set_attributes_from_info(*arguments, &block); end
  def set_display_name(*arguments, &block); end
  def set_display_name_async(*arguments, &block); end
  def set_display_name_finish(*arguments, &block); end
  def start_mountable(*arguments, &block); end
  def start_mountable_finish(*arguments, &block); end
  def stop_mountable(*arguments, &block); end
  def stop_mountable_finish(*arguments, &block); end
  def supports_thread_contexts(*arguments, &block); end
  def trash(*arguments, &block); end
  def trash_async(*arguments, &block); end
  def trash_finish(*arguments, &block); end
  def unmount_mountable(*arguments, &block); end
  def unmount_mountable_finish(*arguments, &block); end
  def unmount_mountable_with_operation(*arguments, &block); end
  def unmount_mountable_with_operation_finish(*arguments, &block); end
  def uri(*arguments, &block); end
  def uri_scheme(*arguments, &block); end
  extend GLib::Deprecatable
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
module Gio::Icon
  def ==(*arguments, &block); end
  def eql?(other); end
  def hash(*arguments, &block); end
  def inspect; end
  def self.deserialize(*arguments, &block); end
  def self.find(*arguments, &block); end
  def serialize(*arguments, &block); end
  def to_s(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::InetAddress < GLib::Object
  def ==(*arguments, &block); end
  def any?(*arguments, &block); end
  def bytes; end
  def family(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new_any(*arguments, &block); end
  def initialize_new_from_bytes(*arguments, &block); end
  def initialize_new_from_string(*arguments, &block); end
  def initialize_new_loopback(*arguments, &block); end
  def inspect; end
  def link_local?(*arguments, &block); end
  def loopback?(*arguments, &block); end
  def mc_global?(*arguments, &block); end
  def mc_link_local?(*arguments, &block); end
  def mc_node_local?(*arguments, &block); end
  def mc_org_local?(*arguments, &block); end
  def mc_site_local?(*arguments, &block); end
  def multicast?(*arguments, &block); end
  def native_size(*arguments, &block); end
  def parent_instance; end
  def priv; end
  def self.any(family); end
  def self.loopback(family); end
  def site_local?(*arguments, &block); end
  def to_s(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::InputStream < GLib::Object
  def clear_pending(*arguments, &block); end
  def close(*arguments, &block); end
  def close_async(*arguments, &block); end
  def close_finish(*arguments, &block); end
  def closed?(*arguments, &block); end
  def has_pending?(*arguments, &block); end
  def parent_instance; end
  def priv; end
  def read(size = nil); end
  def read_all(size); end
  def read_all_async(*arguments, &block); end
  def read_all_finish(*arguments, &block); end
  def read_all_raw(*arguments, &block); end
  def read_all_raw_compatible(buffer); end
  def read_async(*arguments, &block); end
  def read_bytes(*arguments, &block); end
  def read_bytes_async(*arguments, &block); end
  def read_bytes_finish(*arguments, &block); end
  def read_finish(*arguments, &block); end
  def read_raw(*arguments, &block); end
  def read_raw_compatible(buffer); end
  def self.open(*arguments); end
  def set_pending(*arguments, &block); end
  def skip(*arguments, &block); end
  def skip_async(*arguments, &block); end
  def skip_finish(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::MenuItem < GLib::Object
  def [](*arguments, &block); end
  def []=(name, value); end
  def action; end
  def action=(value); end
  def action_namespace; end
  def action_namespace=(value); end
  def detailed_action=(*arguments, &block); end
  def get_attribute_value(*arguments, &block); end
  def get_link(*arguments, &block); end
  def icon; end
  def icon=(value); end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def initialize_new_from_model(*arguments, &block); end
  def initialize_new_section(*arguments, &block); end
  def initialize_new_submenu(*arguments, &block); end
  def label; end
  def label=(value); end
  def section=(*arguments, &block); end
  def set_action_and_target_value(*arguments, &block); end
  def set_attribute_value(name, value); end
  def set_attribute_value_raw(*arguments, &block); end
  def set_detailed_action(*arguments, &block); end
  def set_icon(*arguments, &block); end
  def set_label(*arguments, &block); end
  def set_link(*arguments, &block); end
  def set_section(*arguments, &block); end
  def set_submenu(*arguments, &block); end
  def submenu=(*arguments, &block); end
  def target; end
  def target=(value); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
module Gio::PollableInputStream
  def can_poll?(*arguments, &block); end
  def create_source(&block); end
  def create_source_raw(*arguments, &block); end
  def read_nonblocking(size = nil); end
  def read_nonblocking_raw(*arguments, &block); end
  def read_nonblocking_raw_compatible(buffer); end
  def readable?(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
module Gio::PollableOutputStream
  def can_poll?(*arguments, &block); end
  def create_source(&block); end
  def create_source_raw(*arguments, &block); end
  def writable?(*arguments, &block); end
  def write_nonblocking(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
module Gio::Resources
  def self.enumerate_children(path, flags = nil); end
  def self.enumerate_children_raw(*arguments, &block); end
  def self.get_info(path, flags = nil); end
  def self.get_info_raw(*arguments, &block); end
  def self.lookup_data(path, flags = nil); end
  def self.lookup_data_raw(*arguments, &block); end
  def self.open_stream(path, flags = nil); end
  def self.open_stream_raw(*arguments, &block); end
  def self.register(*arguments, &block); end
  def self.unregister(*arguments, &block); end
end
class Gio::Settings < GLib::Object
  def [](*arguments, &block); end
  def []=(key, value); end
  def apply(*arguments, &block); end
  def backend; end
  def bind(*arguments, &block); end
  def bind_writable(*arguments, &block); end
  def children(*arguments, &block); end
  def create_action(*arguments, &block); end
  def delay(*arguments, &block); end
  def delay_apply?; end
  def get_boolean(*arguments, &block); end
  def get_child(*arguments, &block); end
  def get_default_value(*arguments, &block); end
  def get_double(*arguments, &block); end
  def get_enum(*arguments, &block); end
  def get_flags(*arguments, &block); end
  def get_int(*arguments, &block); end
  def get_int64(*arguments, &block); end
  def get_mapped(*arguments, &block); end
  def get_range(*arguments, &block); end
  def get_string(*arguments, &block); end
  def get_strv(*arguments, &block); end
  def get_uint(*arguments, &block); end
  def get_uint64(*arguments, &block); end
  def get_user_value(*arguments, &block); end
  def get_value(*arguments, &block); end
  def has_unapplied?(*arguments, &block); end
  def initialize(*args); end
  def initialize_new(*arguments, &block); end
  def initialize_new_full(*arguments, &block); end
  def initialize_new_with_backend(*arguments, &block); end
  def initialize_new_with_backend_and_path(*arguments, &block); end
  def initialize_new_with_path(*arguments, &block); end
  def initialize_raw(*arguments, &block); end
  def initialize_with_hash_args(options); end
  def keys(*arguments, &block); end
  def parent_instance; end
  def path; end
  def priv; end
  def range_check(*arguments, &block); end
  def reset(*arguments, &block); end
  def revert(*arguments, &block); end
  def schema; end
  def schema_id; end
  def self.relocatable_schemas(*arguments, &block); end
  def self.schemas(*arguments, &block); end
  def self.sync(*arguments, &block); end
  def self.unbind(*arguments, &block); end
  def set_boolean(*arguments, &block); end
  def set_double(*arguments, &block); end
  def set_enum(*arguments, &block); end
  def set_flags(*arguments, &block); end
  def set_int(*arguments, &block); end
  def set_int64(*arguments, &block); end
  def set_string(*arguments, &block); end
  def set_strv(*arguments, &block); end
  def set_uint(*arguments, &block); end
  def set_uint64(*arguments, &block); end
  def set_value(key, value); end
  def set_value_raw(*arguments, &block); end
  def settings_schema; end
  def writable?(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::SettingsSchemaSource < GLib::Boxed
  def initialize(*arguments, &block); end
  def initialize_new_from_directory(*arguments, &block); end
  def list_schemas(recursive_or_options = nil); end
  def list_schemas_raw(*arguments, &block); end
  def lookup(*arguments, &block); end
  def ref(*arguments, &block); end
  def self.default(*arguments, &block); end
  def unref(*arguments, &block); end
end
class Gio::SimpleAction < GLib::Object
  def enabled=(*arguments, &block); end
  def enabled?; end
  def initialize(name, parameter_type = nil, state = nil); end
  def initialize_new(*arguments, &block); end
  def initialize_new_stateful(*arguments, &block); end
  def initialize_raw(*arguments, &block); end
  def name; end
  def parameter_type; end
  def set_enabled(*arguments, &block); end
  def set_state(*arguments, &block); end
  def set_state_hint(*arguments, &block); end
  def state; end
  def state=(*arguments, &block); end
  def state_hint=(*arguments, &block); end
  def state_type; end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
module GLib
  def self.gio_has_unix?(*margs, &mblock); end
  extend GLib::Deprecatable
end
class Gio::Error < StandardError
end
class Gio::MimeType
  def content_type; end
  def initialize(type); end
  def to_s; end
end
module Gio::DBus
  def self.address?(*arguments, &block); end
  def self.address_escape_value(*arguments, &block); end
  def self.address_get_for_bus_sync(*arguments, &block); end
  def self.address_get_stream(*arguments, &block); end
  def self.address_get_stream_finish(*arguments, &block); end
  def self.address_get_stream_sync(*arguments, &block); end
  def self.annotation_info_lookup(*arguments, &block); end
  def self.error_encode_gerror(*arguments, &block); end
  def self.error_get_remote_error(*arguments, &block); end
  def self.error_is_remote_error?(*arguments, &block); end
  def self.error_new_for_dbus_error(*arguments, &block); end
  def self.error_quark(*arguments, &block); end
  def self.error_register_error(*arguments, &block); end
  def self.error_register_error_domain(*arguments, &block); end
  def self.error_strip_remote_error(*arguments, &block); end
  def self.error_unregister_error(*arguments, &block); end
  def self.generate_guid(*arguments, &block); end
  def self.guid?(*arguments, &block); end
  def self.gvalue_to_gvariant(*arguments, &block); end
  def self.gvariant_to_gvalue(*arguments, &block); end
  def self.interface_name?(*arguments, &block); end
  def self.member_name?(*arguments, &block); end
  def self.name?(*arguments, &block); end
  def self.supported_address?(*arguments, &block); end
  def self.unique_name?(*arguments, &block); end
end
module Gio::ActionGroup
  def action_added(*arguments, &block); end
  def action_enabled_changed(*arguments, &block); end
  def action_removed(*arguments, &block); end
  def action_state_changed(*arguments, &block); end
  def actions(*arguments, &block); end
  def activate_action(*arguments, &block); end
  def change_action_state(*arguments, &block); end
  def get_action_enabled(*arguments, &block); end
  def get_action_parameter_type(*arguments, &block); end
  def get_action_state(*arguments, &block); end
  def get_action_state_hint(*arguments, &block); end
  def get_action_state_type(*arguments, &block); end
  def has_action?(*arguments, &block); end
  def query_action(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
module Gio::AppInfo
  def ==(*arguments, &block); end
  def add_supports_type(*arguments, &block); end
  def as_default_for_extension=(*arguments, &block); end
  def as_default_for_type=(*arguments, &block); end
  def as_last_used_for_type=(*arguments, &block); end
  def can_delete?(*arguments, &block); end
  def can_remove_supports_type?(*arguments, &block); end
  def commandline(*arguments, &block); end
  def delete(*arguments, &block); end
  def description(*arguments, &block); end
  def display_name(*arguments, &block); end
  def dup(*arguments, &block); end
  def executable(*arguments, &block); end
  def icon(*arguments, &block); end
  def id(*arguments, &block); end
  def launch(*arguments, &block); end
  def launch_uris(*arguments, &block); end
  def name(*arguments, &block); end
  def remove_supports_type(*arguments, &block); end
  def self.all(*arguments, &block); end
  def self.create_from_commandline(*arguments, &block); end
  def self.get_all_for_type(*arguments, &block); end
  def self.get_default_for_type(*arguments, &block); end
  def self.get_default_for_uri_scheme(*arguments, &block); end
  def self.get_fallback_for_type(*arguments, &block); end
  def self.get_recommended_for_type(*arguments, &block); end
  def self.launch_default_for_uri(*arguments, &block); end
  def self.launch_default_for_uri_async(*arguments, &block); end
  def self.launch_default_for_uri_finish(*arguments, &block); end
  def self.reset_type_associations(*arguments, &block); end
  def set_as_default_for_extension(*arguments, &block); end
  def set_as_default_for_type(*arguments, &block); end
  def set_as_last_used_for_type(*arguments, &block); end
  def should_show(*arguments, &block); end
  def supported_types(*arguments, &block); end
  def supports_files(*arguments, &block); end
  def supports_uris(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
module Gio::AsyncInitable
  def init_async(*arguments, &block); end
  def init_finish(*arguments, &block); end
  def new_finish(*arguments, &block); end
  def self.newv_async(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
module Gio::AsyncResult
  def legacy_propagate_error(*arguments, &block); end
  def source_object(*arguments, &block); end
  def tagged?(*arguments, &block); end
  def user_data(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
module Gio::Converter
  def convert(*arguments, &block); end
  def reset(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
module Gio::DBusInterface
  def info(*arguments, &block); end
  def object(*arguments, &block); end
  def object=(*arguments, &block); end
  def set_object(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
module Gio::DBusObject
  def get_interface(*arguments, &block); end
  def interfaces(*arguments, &block); end
  def object_path(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
module Gio::DBusObjectManager
  def get_interface(*arguments, &block); end
  def get_object(*arguments, &block); end
  def object_path(*arguments, &block); end
  def objects(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
module Gio::DatagramBased
  def condition_check(*arguments, &block); end
  def condition_wait(*arguments, &block); end
  def create_source(*arguments, &block); end
  def receive_messages(*arguments, &block); end
  def send_messages(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
module Gio::DesktopAppInfoLookup
  def get_default_for_uri_scheme(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
module Gio::Drive
  def can_eject?(*arguments, &block); end
  def can_poll_for_media?(*arguments, &block); end
  def can_start?(*arguments, &block); end
  def can_start_degraded?(*arguments, &block); end
  def can_stop?(*arguments, &block); end
  def eject(*arguments, &block); end
  def eject_finish(*arguments, &block); end
  def eject_with_operation(*arguments, &block); end
  def eject_with_operation_finish(*arguments, &block); end
  def enumerate_identifiers(*arguments, &block); end
  def get_identifier(*arguments, &block); end
  def has_media?(*arguments, &block); end
  def has_volumes?(*arguments, &block); end
  def icon(*arguments, &block); end
  def media_check_automatic?(*arguments, &block); end
  def media_removable?(*arguments, &block); end
  def name(*arguments, &block); end
  def poll_for_media(*arguments, &block); end
  def poll_for_media_finish(*arguments, &block); end
  def removable?(*arguments, &block); end
  def sort_key(*arguments, &block); end
  def start(*arguments, &block); end
  def start_finish(*arguments, &block); end
  def start_stop_type(*arguments, &block); end
  def stop(*arguments, &block); end
  def stop_finish(*arguments, &block); end
  def symbolic_icon(*arguments, &block); end
  def volumes(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
module Gio::DtlsClientConnection
  def accepted_cas(*arguments, &block); end
  def server_identity(*arguments, &block); end
  def server_identity=(*arguments, &block); end
  def set_server_identity(*arguments, &block); end
  def set_validation_flags(*arguments, &block); end
  def validation_flags(*arguments, &block); end
  def validation_flags=(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
module Gio::DtlsConnection
  def base_socket; end
  def certificate(*arguments, &block); end
  def certificate=(*arguments, &block); end
  def close(*arguments, &block); end
  def close_async(*arguments, &block); end
  def close_finish(*arguments, &block); end
  def database(*arguments, &block); end
  def database=(*arguments, &block); end
  def emit_accept_certificate(*arguments, &block); end
  def handshake(*arguments, &block); end
  def handshake_async(*arguments, &block); end
  def handshake_finish(*arguments, &block); end
  def interaction(*arguments, &block); end
  def interaction=(*arguments, &block); end
  def peer_certificate(*arguments, &block); end
  def peer_certificate_errors(*arguments, &block); end
  def rehandshake_mode(*arguments, &block); end
  def rehandshake_mode=(*arguments, &block); end
  def require_close_notify=(*arguments, &block); end
  def require_close_notify?(*arguments, &block); end
  def set_certificate(*arguments, &block); end
  def set_database(*arguments, &block); end
  def set_interaction(*arguments, &block); end
  def set_rehandshake_mode(*arguments, &block); end
  def set_require_close_notify(*arguments, &block); end
  def shutdown(*arguments, &block); end
  def shutdown_async(*arguments, &block); end
  def shutdown_finish(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
module Gio::DtlsServerConnection
  def authentication_mode; end
  def authentication_mode=(val); end
  def set_authentication_mode(val); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
module Gio::FileDescriptorBased
  def fd(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
module Gio::Initable
  def init(*arguments, &block); end
  def self.newv(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
module Gio::ListModel
  def get_item(*arguments, &block); end
  def item_type(*arguments, &block); end
  def items_changed(*arguments, &block); end
  def n_items(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
module Gio::LoadableIcon
  def load(*arguments, &block); end
  def load_async(*arguments, &block); end
  def load_finish(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
module Gio::Mount
  def can_eject?(*arguments, &block); end
  def can_unmount?(*arguments, &block); end
  def default_location(*arguments, &block); end
  def drive(*arguments, &block); end
  def eject(*arguments, &block); end
  def eject_finish(*arguments, &block); end
  def eject_with_operation(*arguments, &block); end
  def eject_with_operation_finish(*arguments, &block); end
  def guess_content_type(*arguments, &block); end
  def guess_content_type_finish(*arguments, &block); end
  def guess_content_type_sync(*arguments, &block); end
  def icon(*arguments, &block); end
  def name(*arguments, &block); end
  def remount(*arguments, &block); end
  def remount_finish(*arguments, &block); end
  def root(*arguments, &block); end
  def shadow(*arguments, &block); end
  def shadowed?(*arguments, &block); end
  def sort_key(*arguments, &block); end
  def symbolic_icon(*arguments, &block); end
  def unmount(*arguments, &block); end
  def unmount_finish(*arguments, &block); end
  def unmount_with_operation(*arguments, &block); end
  def unmount_with_operation_finish(*arguments, &block); end
  def unshadow(*arguments, &block); end
  def uuid(*arguments, &block); end
  def volume(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
module Gio::NetworkMonitor
  def can_reach?(*arguments, &block); end
  def can_reach_async(*arguments, &block); end
  def can_reach_finish?(*arguments, &block); end
  def connectivity(*arguments, &block); end
  def network_available?(*arguments, &block); end
  def network_metered?(*arguments, &block); end
  def self.default(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
module Gio::Proxy
  def connect(*arguments, &block); end
  def connect_async(*arguments, &block); end
  def connect_finish(*arguments, &block); end
  def self.get_default_for_protocol(*arguments, &block); end
  def supports_hostname(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
module Gio::ProxyResolver
  def lookup(*arguments, &block); end
  def lookup_async(*arguments, &block); end
  def lookup_finish(*arguments, &block); end
  def self.default(*arguments, &block); end
  def supported?(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
module Gio::RemoteActionGroup
  def activate_action_full(*arguments, &block); end
  def change_action_state_full(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
module Gio::Seekable
  def can_seek?(*arguments, &block); end
  def can_truncate?(*arguments, &block); end
  def seek(*arguments, &block); end
  def tell(*arguments, &block); end
  def truncate(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
module Gio::SocketConnectable
  def enumerate(*arguments, &block); end
  def inspect; end
  def proxy_enumerate(*arguments, &block); end
  def to_s(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
module Gio::TlsBackend
  def certificate_type(*arguments, &block); end
  def client_connection_type(*arguments, &block); end
  def default_database(*arguments, &block); end
  def dtls_client_connection_type(*arguments, &block); end
  def dtls_server_connection_type(*arguments, &block); end
  def file_database_type(*arguments, &block); end
  def self.default(*arguments, &block); end
  def server_connection_type(*arguments, &block); end
  def supports_dtls(*arguments, &block); end
  def supports_tls(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
module Gio::TlsClientConnection
  def accepted_cas(*arguments, &block); end
  def copy_session_state(*arguments, &block); end
  def server_identity(*arguments, &block); end
  def server_identity=(*arguments, &block); end
  def set_server_identity(*arguments, &block); end
  def set_use_ssl3(*arguments, &block); end
  def set_validation_flags(*arguments, &block); end
  def use_ssl3=(*arguments, &block); end
  def use_ssl3?(*arguments, &block); end
  def validation_flags(*arguments, &block); end
  def validation_flags=(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
module Gio::TlsFileDatabase
  def anchors; end
  def anchors=(val); end
  def set_anchors(val); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
module Gio::TlsServerConnection
  def authentication_mode; end
  def authentication_mode=(val); end
  def set_authentication_mode(val); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
module Gio::Volume
  def activation_root(*arguments, &block); end
  def can_eject?(*arguments, &block); end
  def can_mount?(*arguments, &block); end
  def drive(*arguments, &block); end
  def eject(*arguments, &block); end
  def eject_finish(*arguments, &block); end
  def eject_with_operation(*arguments, &block); end
  def eject_with_operation_finish(*arguments, &block); end
  def enumerate_identifiers(*arguments, &block); end
  def get_identifier(*arguments, &block); end
  def icon(*arguments, &block); end
  def mount(*arguments, &block); end
  def mount_finish(*arguments, &block); end
  def name(*arguments, &block); end
  def should_automount(*arguments, &block); end
  def sort_key(*arguments, &block); end
  def symbolic_icon(*arguments, &block); end
  def uuid(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::ActionEntry
  def activate; end
  def change_state; end
  def name; end
  def name=(value); end
  def padding; end
  def parameter_type; end
  def parameter_type=(value); end
  def state; end
  def state=(value); end
end
class Gio::AppInfoCreateFlags < GLib::Flags
  def needs_terminal?; end
  def none?; end
  def supports_startup_notification?; end
  def supports_uris?; end
end
class Gio::AppInfoMonitor < GLib::Object
  def self.get(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::AppLaunchContext < GLib::Object
  def environment(*arguments, &block); end
  def get_display(*arguments, &block); end
  def get_startup_notify_id(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def launch_failed(*arguments, &block); end
  def parent_instance; end
  def priv; end
  def setenv(*arguments, &block); end
  def unsetenv(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::Application < GLib::Object
  def action_group=(*arguments, &block); end
  def activate(*arguments, &block); end
  def add_main_option(*arguments, &block); end
  def add_main_option_entries(*arguments, &block); end
  def add_option_group(*arguments, &block); end
  def application_id(*arguments, &block); end
  def application_id=(*arguments, &block); end
  def bind_busy_property(*arguments, &block); end
  def busy?(*arguments, &block); end
  def dbus_connection(*arguments, &block); end
  def dbus_object_path(*arguments, &block); end
  def flags(*arguments, &block); end
  def flags=(*arguments, &block); end
  def hold(*arguments, &block); end
  def inactivity_timeout(*arguments, &block); end
  def inactivity_timeout=(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def mark_busy(*arguments, &block); end
  def open(*arguments, &block); end
  def option_context_description=(*arguments, &block); end
  def option_context_parameter_string=(*arguments, &block); end
  def option_context_summary=(*arguments, &block); end
  def parent_instance; end
  def priv; end
  def quit(*arguments, &block); end
  def register(*arguments, &block); end
  def registered?(*arguments, &block); end
  def release(*arguments, &block); end
  def remote?(*arguments, &block); end
  def resource_base_path(*arguments, &block); end
  def resource_base_path=(*arguments, &block); end
  def run(*arguments, &block); end
  def self.default(*arguments, &block); end
  def self.id_is_valid?(*arguments, &block); end
  def send_notification(*arguments, &block); end
  def set_action_group(*arguments, &block); end
  def set_application_id(*arguments, &block); end
  def set_default(*arguments, &block); end
  def set_flags(*arguments, &block); end
  def set_inactivity_timeout(*arguments, &block); end
  def set_option_context_description(*arguments, &block); end
  def set_option_context_parameter_string(*arguments, &block); end
  def set_option_context_summary(*arguments, &block); end
  def set_resource_base_path(*arguments, &block); end
  def unbind_busy_property(*arguments, &block); end
  def unmark_busy(*arguments, &block); end
  def withdraw_notification(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::ApplicationFlags < GLib::Flags
  def can_override_app_id?; end
  def flags_none?; end
  def handles_command_line?; end
  def handles_open?; end
  def is_launcher?; end
  def is_service?; end
  def non_unique?; end
  def send_environment?; end
end
class Gio::AskPasswordFlags < GLib::Flags
  def anonymous_supported?; end
  def need_domain?; end
  def need_password?; end
  def need_username?; end
  def saving_supported?; end
end
class Gio::FilterInputStream < Gio::InputStream
  def base_stream(*arguments, &block); end
  def close_base_stream=(*arguments, &block); end
  def close_base_stream?(*arguments, &block); end
  def parent_instance; end
  def set_close_base_stream(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::BufferedInputStream < Gio::FilterInputStream
  def available(*arguments, &block); end
  def buffer_size(*arguments, &block); end
  def buffer_size=(*arguments, &block); end
  def fill(*arguments, &block); end
  def fill_async(*arguments, &block); end
  def fill_finish(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def initialize_new_sized(*arguments, &block); end
  def parent_instance; end
  def peek(*arguments, &block); end
  def peek_buffer(*arguments, &block); end
  def priv; end
  def read_byte(*arguments, &block); end
  def set_buffer_size(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::OutputStream < GLib::Object
  def clear_pending(*arguments, &block); end
  def close(*arguments, &block); end
  def close_async(*arguments, &block); end
  def close_finish(*arguments, &block); end
  def closed?(*arguments, &block); end
  def closing?(*arguments, &block); end
  def flush(*arguments, &block); end
  def flush_async(*arguments, &block); end
  def flush_finish(*arguments, &block); end
  def has_pending?(*arguments, &block); end
  def parent_instance; end
  def priv; end
  def set_pending(*arguments, &block); end
  def splice(*arguments, &block); end
  def splice_async(*arguments, &block); end
  def splice_finish(*arguments, &block); end
  def write(*arguments, &block); end
  def write_all(*arguments, &block); end
  def write_all_async(*arguments, &block); end
  def write_all_finish(*arguments, &block); end
  def write_async(*arguments, &block); end
  def write_bytes(*arguments, &block); end
  def write_bytes_async(*arguments, &block); end
  def write_bytes_finish(*arguments, &block); end
  def write_finish(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::FilterOutputStream < Gio::OutputStream
  def base_stream(*arguments, &block); end
  def close_base_stream=(*arguments, &block); end
  def close_base_stream?(*arguments, &block); end
  def parent_instance; end
  def set_close_base_stream(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::BufferedOutputStream < Gio::FilterOutputStream
  def auto_grow=(*arguments, &block); end
  def auto_grow?(*arguments, &block); end
  def buffer_size(*arguments, &block); end
  def buffer_size=(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def initialize_new_sized(*arguments, &block); end
  def parent_instance; end
  def priv; end
  def set_auto_grow(*arguments, &block); end
  def set_buffer_size(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::BusNameOwnerFlags < GLib::Flags
  def allow_replacement?; end
  def do_not_queue?; end
  def none?; end
  def replace?; end
end
class Gio::BusNameWatcherFlags < GLib::Flags
  def auto_start?; end
  def none?; end
end
class Gio::BusType < GLib::Enum
end
class Gio::BytesIcon < GLib::Object
  def bytes(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::Cancellable < GLib::Object
  def cancel(*arguments, &block); end
  def cancelled?(*arguments, &block); end
  def connect(*arguments, &block); end
  def disconnect(*arguments, &block); end
  def fd(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def make_pollfd(*arguments, &block); end
  def parent_instance; end
  def pop_current(*arguments, &block); end
  def priv; end
  def push_current(*arguments, &block); end
  def release_fd(*arguments, &block); end
  def reset(*arguments, &block); end
  def self.current(*arguments, &block); end
  def set_error_if_cancelled(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::CharsetConverter < GLib::Object
  def from_charset; end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def num_fallbacks(*arguments, &block); end
  def set_use_fallback(*arguments, &block); end
  def to_charset; end
  def use_fallback=(*arguments, &block); end
  def use_fallback?(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::ConverterFlags < GLib::Flags
  def flush?; end
  def input_at_end?; end
  def none?; end
end
class Gio::ConverterInputStream < Gio::FilterInputStream
  def converter(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def parent_instance; end
  def priv; end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::ConverterOutputStream < Gio::FilterOutputStream
  def converter(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def parent_instance; end
  def priv; end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::ConverterResult < GLib::Enum
end
class Gio::Credentials < GLib::Object
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def inspect; end
  def same_user?(*arguments, &block); end
  def set_native(*arguments, &block); end
  def set_unix_user(*arguments, &block); end
  def to_s(*arguments, &block); end
  def unix_pid(*arguments, &block); end
  def unix_user(*arguments, &block); end
  def unix_user=(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::CredentialsType < GLib::Enum
end
class Gio::DBusActionGroup < GLib::Object
  def self.get(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::DBusAnnotationInfo < GLib::Boxed
  def annotations; end
  def annotations=(value); end
  def key; end
  def key=(value); end
  def ref(*arguments, &block); end
  def ref_count; end
  def ref_count=(value); end
  def self.lookup(*arguments, &block); end
  def unref(*arguments, &block); end
  def value; end
  def value=(value); end
end
class Gio::DBusArgInfo < GLib::Boxed
  def annotations; end
  def annotations=(value); end
  def name; end
  def name=(value); end
  def ref(*arguments, &block); end
  def ref_count; end
  def ref_count=(value); end
  def signature; end
  def signature=(value); end
  def unref(*arguments, &block); end
end
class Gio::DBusAuthObserver < GLib::Object
  def allow_mechanism(*arguments, &block); end
  def authorize_authenticated_peer(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::DBusCallFlags < GLib::Flags
  def allow_interactive_authorization?; end
  def no_auto_start?; end
  def none?; end
end
class Gio::DBusCapabilityFlags < GLib::Flags
  def none?; end
  def unix_fd_passing?; end
end
class Gio::DBusConnection < GLib::Object
  def add_filter(*arguments, &block); end
  def call(*arguments, &block); end
  def call_finish(*arguments, &block); end
  def call_sync(*arguments, &block); end
  def call_with_unix_fd_list(*arguments, &block); end
  def call_with_unix_fd_list_finish(*arguments, &block); end
  def call_with_unix_fd_list_sync(*arguments, &block); end
  def capabilities(*arguments, &block); end
  def close(*arguments, &block); end
  def close_finish(*arguments, &block); end
  def close_sync(*arguments, &block); end
  def closed?(*arguments, &block); end
  def emit_signal(*arguments, &block); end
  def exit_on_close=(*arguments, &block); end
  def exit_on_close?(*arguments, &block); end
  def export_action_group(*arguments, &block); end
  def export_menu_model(*arguments, &block); end
  def flush(*arguments, &block); end
  def flush_finish(*arguments, &block); end
  def flush_sync(*arguments, &block); end
  def guid(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new_finish(*arguments, &block); end
  def initialize_new_for_address_finish(*arguments, &block); end
  def initialize_new_for_address_sync(*arguments, &block); end
  def initialize_new_sync(*arguments, &block); end
  def last_serial(*arguments, &block); end
  def peer_credentials(*arguments, &block); end
  def register_object(*arguments, &block); end
  def register_subtree(*arguments, &block); end
  def remove_filter(*arguments, &block); end
  def self.new_for_address(*arguments, &block); end
  def send_message(*arguments, &block); end
  def send_message_with_reply(*arguments, &block); end
  def send_message_with_reply_finish(*arguments, &block); end
  def send_message_with_reply_sync(*arguments, &block); end
  def set_exit_on_close(*arguments, &block); end
  def signal_subscribe(*arguments, &block); end
  def signal_unsubscribe(*arguments, &block); end
  def start_message_processing(*arguments, &block); end
  def stream(*arguments, &block); end
  def unexport_action_group(*arguments, &block); end
  def unexport_menu_model(*arguments, &block); end
  def unique_name(*arguments, &block); end
  def unregister_object(*arguments, &block); end
  def unregister_subtree(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::DBusConnectionFlags < GLib::Flags
  def authentication_allow_anonymous?; end
  def authentication_client?; end
  def authentication_server?; end
  def delay_message_processing?; end
  def message_bus_connection?; end
  def none?; end
end
class Gio::DBusErrorEntry
  def dbus_error_name; end
  def dbus_error_name=(value); end
  def error_code; end
  def error_code=(value); end
end
class Gio::DBusInterfaceInfo < GLib::Boxed
  def annotations; end
  def annotations=(value); end
  def cache_build(*arguments, &block); end
  def cache_release(*arguments, &block); end
  def generate_xml(*arguments, &block); end
  def lookup_method(*arguments, &block); end
  def lookup_property(*arguments, &block); end
  def lookup_signal(*arguments, &block); end
  def methods; end
  def methods=(value); end
  def name; end
  def name=(value); end
  def properties; end
  def properties=(value); end
  def ref(*arguments, &block); end
  def ref_count; end
  def ref_count=(value); end
  def signals; end
  def signals=(value); end
  def unref(*arguments, &block); end
end
class Gio::DBusInterfaceSkeleton < GLib::Object
  def connection(*arguments, &block); end
  def connections(*arguments, &block); end
  def export(*arguments, &block); end
  def flags(*arguments, &block); end
  def flags=(*arguments, &block); end
  def flush(*arguments, &block); end
  def g_flags; end
  def g_flags=(val); end
  def has_connection?(*arguments, &block); end
  def info(*arguments, &block); end
  def object_path(*arguments, &block); end
  def parent_instance; end
  def priv; end
  def properties(*arguments, &block); end
  def set_flags(*arguments, &block); end
  def set_g_flags(val); end
  def unexport(*arguments, &block); end
  def unexport_from_connection(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::DBusInterfaceSkeletonFlags < GLib::Flags
  def handle_method_invocations_in_thread?; end
  def none?; end
end
class Gio::DBusInterfaceVTable
  def get_property; end
  def get_property=(value); end
  def method_call; end
  def method_call=(value); end
  def padding; end
  def set_property; end
  def set_property=(value); end
end
class Gio::MenuModel < GLib::Object
  def get_item_attribute_value(*arguments, &block); end
  def get_item_link(*arguments, &block); end
  def items_changed(*arguments, &block); end
  def iterate_item_attributes(*arguments, &block); end
  def iterate_item_links(*arguments, &block); end
  def mutable?(*arguments, &block); end
  def n_items(*arguments, &block); end
  def parent_instance; end
  def priv; end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::DBusMenuModel < Gio::MenuModel
  def self.get(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::DBusMessage < GLib::Object
  def arg0(*arguments, &block); end
  def body(*arguments, &block); end
  def body=(*arguments, &block); end
  def byte_order(*arguments, &block); end
  def byte_order=(*arguments, &block); end
  def copy(*arguments, &block); end
  def destination(*arguments, &block); end
  def destination=(*arguments, &block); end
  def error_name(*arguments, &block); end
  def error_name=(*arguments, &block); end
  def flags(*arguments, &block); end
  def flags=(*arguments, &block); end
  def get_header(*arguments, &block); end
  def header_fields(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def initialize_new_from_blob(*arguments, &block); end
  def initialize_new_method_call(*arguments, &block); end
  def initialize_new_signal(*arguments, &block); end
  def interface(*arguments, &block); end
  def interface=(*arguments, &block); end
  def lock(*arguments, &block); end
  def locked?(*arguments, &block); end
  def member(*arguments, &block); end
  def member=(*arguments, &block); end
  def message_type(*arguments, &block); end
  def message_type=(*arguments, &block); end
  def new_method_error_literal(*arguments, &block); end
  def new_method_reply(*arguments, &block); end
  def num_unix_fds(*arguments, &block); end
  def num_unix_fds=(*arguments, &block); end
  def path(*arguments, &block); end
  def path=(*arguments, &block); end
  def print(*arguments, &block); end
  def reply_serial(*arguments, &block); end
  def reply_serial=(*arguments, &block); end
  def self.bytes_needed(*arguments, &block); end
  def sender(*arguments, &block); end
  def sender=(*arguments, &block); end
  def serial(*arguments, &block); end
  def serial=(*arguments, &block); end
  def set_body(*arguments, &block); end
  def set_byte_order(*arguments, &block); end
  def set_destination(*arguments, &block); end
  def set_error_name(*arguments, &block); end
  def set_flags(*arguments, &block); end
  def set_header(*arguments, &block); end
  def set_interface(*arguments, &block); end
  def set_member(*arguments, &block); end
  def set_message_type(*arguments, &block); end
  def set_num_unix_fds(*arguments, &block); end
  def set_path(*arguments, &block); end
  def set_reply_serial(*arguments, &block); end
  def set_sender(*arguments, &block); end
  def set_serial(*arguments, &block); end
  def set_signature(*arguments, &block); end
  def set_unix_fd_list(*arguments, &block); end
  def signature(*arguments, &block); end
  def signature=(*arguments, &block); end
  def to_blob(*arguments, &block); end
  def to_gerror(*arguments, &block); end
  def unix_fd_list(*arguments, &block); end
  def unix_fd_list=(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::DBusMessageByteOrder < GLib::Enum
end
class Gio::DBusMessageFlags < GLib::Flags
  def allow_interactive_authorization?; end
  def no_auto_start?; end
  def no_reply_expected?; end
  def none?; end
end
class Gio::DBusMessageHeaderField < GLib::Enum
end
class Gio::DBusMessageType < GLib::Enum
end
class Gio::DBusMethodInfo < GLib::Boxed
  def annotations; end
  def annotations=(value); end
  def in_args; end
  def in_args=(value); end
  def name; end
  def name=(value); end
  def out_args; end
  def out_args=(value); end
  def ref(*arguments, &block); end
  def ref_count; end
  def ref_count=(value); end
  def unref(*arguments, &block); end
end
class Gio::DBusMethodInvocation < GLib::Object
  def connection(*arguments, &block); end
  def interface_name(*arguments, &block); end
  def message(*arguments, &block); end
  def method_info(*arguments, &block); end
  def method_name(*arguments, &block); end
  def object_path(*arguments, &block); end
  def parameters(*arguments, &block); end
  def property_info(*arguments, &block); end
  def return_dbus_error(*arguments, &block); end
  def return_error_literal(*arguments, &block); end
  def return_gerror(*arguments, &block); end
  def return_value(*arguments, &block); end
  def return_value_with_unix_fd_list(*arguments, &block); end
  def sender(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::DBusNodeInfo < GLib::Boxed
  def annotations; end
  def annotations=(value); end
  def generate_xml(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new_for_xml(*arguments, &block); end
  def interfaces; end
  def interfaces=(value); end
  def lookup_interface(*arguments, &block); end
  def nodes; end
  def nodes=(value); end
  def path; end
  def path=(value); end
  def ref(*arguments, &block); end
  def ref_count; end
  def ref_count=(value); end
  def unref(*arguments, &block); end
end
class Gio::DBusObjectManagerClient < GLib::Object
  def connection(*arguments, &block); end
  def flags(*arguments, &block); end
  def get_proxy_type_destroy_notify; end
  def get_proxy_type_func; end
  def get_proxy_type_user_data; end
  def initialize(*arguments, &block); end
  def initialize_new_finish(*arguments, &block); end
  def initialize_new_for_bus_finish(*arguments, &block); end
  def initialize_new_for_bus_sync(*arguments, &block); end
  def initialize_new_sync(*arguments, &block); end
  def name(*arguments, &block); end
  def name_owner(*arguments, &block); end
  def object_path; end
  def parent_instance; end
  def priv; end
  def self.new_for_bus(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::DBusObjectManagerClientFlags < GLib::Flags
  def do_not_auto_start?; end
  def none?; end
end
class Gio::DBusObjectManagerServer < GLib::Object
  def connection(*arguments, &block); end
  def connection=(*arguments, &block); end
  def export(*arguments, &block); end
  def export_uniquely(*arguments, &block); end
  def exported?(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def object_path; end
  def parent_instance; end
  def priv; end
  def set_connection(*arguments, &block); end
  def unexport(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::DBusObjectProxy < GLib::Object
  def connection(*arguments, &block); end
  def g_connection; end
  def g_object_path; end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def parent_instance; end
  def priv; end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::DBusObjectSkeleton < GLib::Object
  def add_interface(*arguments, &block); end
  def flush(*arguments, &block); end
  def g_object_path; end
  def g_object_path=(val); end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def object_path=(*arguments, &block); end
  def parent_instance; end
  def priv; end
  def remove_interface(*arguments, &block); end
  def remove_interface_by_name(*arguments, &block); end
  def set_g_object_path(val); end
  def set_object_path(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::DBusPropertyInfo < GLib::Boxed
  def annotations; end
  def annotations=(value); end
  def flags; end
  def flags=(value); end
  def name; end
  def name=(value); end
  def ref(*arguments, &block); end
  def ref_count; end
  def ref_count=(value); end
  def signature; end
  def signature=(value); end
  def unref(*arguments, &block); end
end
class Gio::DBusPropertyInfoFlags < GLib::Flags
  def none?; end
  def readable?; end
  def writable?; end
end
class Gio::DBusProxy < GLib::Object
  def cached_property_names(*arguments, &block); end
  def call(*arguments, &block); end
  def call_finish(*arguments, &block); end
  def call_sync(*arguments, &block); end
  def call_with_unix_fd_list(*arguments, &block); end
  def call_with_unix_fd_list_finish(*arguments, &block); end
  def call_with_unix_fd_list_sync(*arguments, &block); end
  def connection(*arguments, &block); end
  def default_timeout(*arguments, &block); end
  def default_timeout=(*arguments, &block); end
  def flags(*arguments, &block); end
  def g_connection; end
  def g_default_timeout; end
  def g_default_timeout=(val); end
  def g_flags; end
  def g_interface_info; end
  def g_interface_info=(val); end
  def g_interface_name; end
  def g_name; end
  def g_name_owner; end
  def g_object_path; end
  def get_cached_property(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new_finish(*arguments, &block); end
  def initialize_new_for_bus_finish(*arguments, &block); end
  def initialize_new_for_bus_sync(*arguments, &block); end
  def initialize_new_sync(*arguments, &block); end
  def interface_info(*arguments, &block); end
  def interface_info=(*arguments, &block); end
  def interface_name(*arguments, &block); end
  def name(*arguments, &block); end
  def name_owner(*arguments, &block); end
  def object_path(*arguments, &block); end
  def parent_instance; end
  def priv; end
  def self.new_for_bus(*arguments, &block); end
  def set_cached_property(*arguments, &block); end
  def set_default_timeout(*arguments, &block); end
  def set_g_default_timeout(val); end
  def set_g_interface_info(val); end
  def set_interface_info(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::DBusProxyFlags < GLib::Flags
  def do_not_auto_start?; end
  def do_not_auto_start_at_construction?; end
  def do_not_connect_signals?; end
  def do_not_load_properties?; end
  def get_invalidated_properties?; end
  def none?; end
end
class Gio::DBusSendMessageFlags < GLib::Flags
  def none?; end
  def preserve_serial?; end
end
class Gio::DBusServer < GLib::Object
  def active?(*arguments, &block); end
  def address; end
  def authentication_observer; end
  def client_address(*arguments, &block); end
  def flags(*arguments, &block); end
  def guid(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new_sync(*arguments, &block); end
  def start(*arguments, &block); end
  def stop(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::DBusServerFlags < GLib::Flags
  def authentication_allow_anonymous?; end
  def none?; end
  def run_in_thread?; end
end
class Gio::DBusSignalFlags < GLib::Flags
  def match_arg0_namespace?; end
  def match_arg0_path?; end
  def no_match_rule?; end
  def none?; end
end
class Gio::DBusSignalInfo < GLib::Boxed
  def annotations; end
  def annotations=(value); end
  def args; end
  def args=(value); end
  def name; end
  def name=(value); end
  def ref(*arguments, &block); end
  def ref_count; end
  def ref_count=(value); end
  def unref(*arguments, &block); end
end
class Gio::DBusSubtreeFlags < GLib::Flags
  def dispatch_to_unenumerated_nodes?; end
  def none?; end
end
class Gio::DBusSubtreeVTable
  def dispatch; end
  def dispatch=(value); end
  def enumerate; end
  def enumerate=(value); end
  def introspect; end
  def introspect=(value); end
  def padding; end
end
class Gio::DataInputStream < Gio::BufferedInputStream
  def byte_order(*arguments, &block); end
  def byte_order=(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def newline_type(*arguments, &block); end
  def newline_type=(*arguments, &block); end
  def parent_instance; end
  def priv; end
  def read_byte(*arguments, &block); end
  def read_int16(*arguments, &block); end
  def read_int32(*arguments, &block); end
  def read_int64(*arguments, &block); end
  def read_line(*arguments, &block); end
  def read_line_async(*arguments, &block); end
  def read_line_finish(*arguments, &block); end
  def read_line_finish_utf8(*arguments, &block); end
  def read_line_utf8(*arguments, &block); end
  def read_uint16(*arguments, &block); end
  def read_uint32(*arguments, &block); end
  def read_uint64(*arguments, &block); end
  def read_until(*arguments, &block); end
  def read_until_async(*arguments, &block); end
  def read_until_finish(*arguments, &block); end
  def read_upto(*arguments, &block); end
  def read_upto_async(*arguments, &block); end
  def read_upto_finish(*arguments, &block); end
  def set_byte_order(*arguments, &block); end
  def set_newline_type(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::DataOutputStream < Gio::FilterOutputStream
  def byte_order(*arguments, &block); end
  def byte_order=(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def parent_instance; end
  def priv; end
  def put_byte(*arguments, &block); end
  def put_int16(*arguments, &block); end
  def put_int32(*arguments, &block); end
  def put_int64(*arguments, &block); end
  def put_string(*arguments, &block); end
  def put_uint16(*arguments, &block); end
  def put_uint32(*arguments, &block); end
  def put_uint64(*arguments, &block); end
  def set_byte_order(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::DataStreamByteOrder < GLib::Enum
end
class Gio::DataStreamNewlineType < GLib::Enum
end
class Gio::DesktopAppInfo < GLib::Object
  def actions(*arguments, &block); end
  def categories(*arguments, &block); end
  def filename(*arguments, &block); end
  def generic_name(*arguments, &block); end
  def get_action_name(*arguments, &block); end
  def get_boolean(*arguments, &block); end
  def get_locale_string(*arguments, &block); end
  def get_show_in(*arguments, &block); end
  def get_string(*arguments, &block); end
  def has_key?(*arguments, &block); end
  def hidden?(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def initialize_new_from_filename(*arguments, &block); end
  def initialize_new_from_keyfile(*arguments, &block); end
  def keywords(*arguments, &block); end
  def launch_action(*arguments, &block); end
  def launch_uris_as_manager(*arguments, &block); end
  def nodisplay?(*arguments, &block); end
  def self.get_implementations(*arguments, &block); end
  def self.search(*arguments, &block); end
  def self.set_desktop_env(*arguments, &block); end
  def startup_wm_class(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::DriveStartFlags < GLib::Flags
  def none?; end
end
class Gio::DriveStartStopType < GLib::Enum
end
class Gio::Emblem < GLib::Object
  def icon(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def initialize_new_with_origin(*arguments, &block); end
  def origin(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::EmblemOrigin < GLib::Enum
end
class Gio::EmblemedIcon < GLib::Object
  def add_emblem(*arguments, &block); end
  def clear_emblems(*arguments, &block); end
  def emblems(*arguments, &block); end
  def gicon; end
  def icon(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def parent_instance; end
  def priv; end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::FileAttributeInfo
  def flags; end
  def flags=(value); end
  def name; end
  def name=(value); end
  def type; end
  def type=(value); end
end
class Gio::FileAttributeInfoFlags < GLib::Flags
  def copy_when_moved?; end
  def copy_with_file?; end
  def none?; end
end
class Gio::FileAttributeInfoList < GLib::Boxed
  def add(*arguments, &block); end
  def dup(*arguments, &block); end
  def infos; end
  def infos=(value); end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def lookup(*arguments, &block); end
  def n_infos; end
  def n_infos=(value); end
  def ref(*arguments, &block); end
  def unref(*arguments, &block); end
end
class Gio::FileAttributeMatcher < GLib::Boxed
  def enumerate_namespace(*arguments, &block); end
  def enumerate_next(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def inspect; end
  def matches(*arguments, &block); end
  def matches_only(*arguments, &block); end
  def ref(*arguments, &block); end
  def subtract(*arguments, &block); end
  def to_s(*arguments, &block); end
  def unref(*arguments, &block); end
end
class Gio::FileAttributeStatus < GLib::Enum
end
class Gio::FileAttributeType < GLib::Enum
end
class Gio::FileCopyFlags < GLib::Flags
  def all_metadata?; end
  def backup?; end
  def no_fallback_for_move?; end
  def nofollow_symlinks?; end
  def none?; end
  def overwrite?; end
  def target_default_perms?; end
end
class Gio::FileCreateFlags < GLib::Flags
  def none?; end
  def private?; end
  def replace_destination?; end
end
class Gio::FileEnumerator < GLib::Object
  def close(*arguments, &block); end
  def close_async(*arguments, &block); end
  def close_finish(*arguments, &block); end
  def closed?(*arguments, &block); end
  def container(*arguments, &block); end
  def get_child(*arguments, &block); end
  def has_pending?(*arguments, &block); end
  def iterate(*arguments, &block); end
  def next_file(*arguments, &block); end
  def next_files_async(*arguments, &block); end
  def next_files_finish(*arguments, &block); end
  def parent_instance; end
  def pending=(*arguments, &block); end
  def priv; end
  def set_pending(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::IOStream < GLib::Object
  def clear_pending(*arguments, &block); end
  def close(*arguments, &block); end
  def close_async(*arguments, &block); end
  def close_finish(*arguments, &block); end
  def closed?(*arguments, &block); end
  def has_pending?(*arguments, &block); end
  def input_stream(*arguments, &block); end
  def output_stream(*arguments, &block); end
  def parent_instance; end
  def priv; end
  def self.splice_finish(*arguments, &block); end
  def set_pending(*arguments, &block); end
  def splice_async(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::FileIOStream < Gio::IOStream
  def etag(*arguments, &block); end
  def parent_instance; end
  def priv; end
  def query_info(*arguments, &block); end
  def query_info_async(*arguments, &block); end
  def query_info_finish(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::FileIcon < GLib::Object
  def file(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::FileInfo < GLib::Object
  def attribute_mask=(*arguments, &block); end
  def backup?(*arguments, &block); end
  def clear_status(*arguments, &block); end
  def content_type(*arguments, &block); end
  def content_type=(*arguments, &block); end
  def copy_into(*arguments, &block); end
  def deletion_date(*arguments, &block); end
  def display_name(*arguments, &block); end
  def display_name=(*arguments, &block); end
  def dup(*arguments, &block); end
  def edit_name(*arguments, &block); end
  def edit_name=(*arguments, &block); end
  def etag(*arguments, &block); end
  def file_type(*arguments, &block); end
  def file_type=(*arguments, &block); end
  def get_attribute_as_string(*arguments, &block); end
  def get_attribute_boolean(*arguments, &block); end
  def get_attribute_byte_string(*arguments, &block); end
  def get_attribute_data(*arguments, &block); end
  def get_attribute_int32(*arguments, &block); end
  def get_attribute_int64(*arguments, &block); end
  def get_attribute_object(*arguments, &block); end
  def get_attribute_status(*arguments, &block); end
  def get_attribute_string(*arguments, &block); end
  def get_attribute_stringv(*arguments, &block); end
  def get_attribute_type(*arguments, &block); end
  def get_attribute_uint32(*arguments, &block); end
  def get_attribute_uint64(*arguments, &block); end
  def has_attribute?(*arguments, &block); end
  def has_namespace?(*arguments, &block); end
  def hidden?(*arguments, &block); end
  def icon(*arguments, &block); end
  def icon=(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def is_hidden=(*arguments, &block); end
  def is_symlink=(*arguments, &block); end
  def list_attributes(*arguments, &block); end
  def modification_time(*arguments, &block); end
  def modification_time=(*arguments, &block); end
  def name(*arguments, &block); end
  def name=(*arguments, &block); end
  def remove_attribute(*arguments, &block); end
  def set_attribute(*arguments, &block); end
  def set_attribute_boolean(*arguments, &block); end
  def set_attribute_byte_string(*arguments, &block); end
  def set_attribute_int32(*arguments, &block); end
  def set_attribute_int64(*arguments, &block); end
  def set_attribute_mask(*arguments, &block); end
  def set_attribute_object(*arguments, &block); end
  def set_attribute_status(*arguments, &block); end
  def set_attribute_string(*arguments, &block); end
  def set_attribute_stringv(*arguments, &block); end
  def set_attribute_uint32(*arguments, &block); end
  def set_attribute_uint64(*arguments, &block); end
  def set_content_type(*arguments, &block); end
  def set_display_name(*arguments, &block); end
  def set_edit_name(*arguments, &block); end
  def set_file_type(*arguments, &block); end
  def set_icon(*arguments, &block); end
  def set_is_hidden(*arguments, &block); end
  def set_is_symlink(*arguments, &block); end
  def set_modification_time(*arguments, &block); end
  def set_name(*arguments, &block); end
  def set_size(*arguments, &block); end
  def set_sort_order(*arguments, &block); end
  def set_symbolic_icon(*arguments, &block); end
  def set_symlink_target(*arguments, &block); end
  def size(*arguments, &block); end
  def size=(*arguments, &block); end
  def sort_order(*arguments, &block); end
  def sort_order=(*arguments, &block); end
  def symbolic_icon(*arguments, &block); end
  def symbolic_icon=(*arguments, &block); end
  def symlink?(*arguments, &block); end
  def symlink_target(*arguments, &block); end
  def symlink_target=(*arguments, &block); end
  def unset_attribute_mask(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::FileInputStream < Gio::InputStream
  def parent_instance; end
  def priv; end
  def query_info(*arguments, &block); end
  def query_info_async(*arguments, &block); end
  def query_info_finish(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::FileMeasureFlags < GLib::Flags
  def apparent_size?; end
  def no_xdev?; end
  def none?; end
  def report_any_error?; end
end
class Gio::FileMonitor < GLib::Object
  def cancel(*arguments, &block); end
  def cancelled?(*arguments, &block); end
  def emit_event(*arguments, &block); end
  def parent_instance; end
  def priv; end
  def rate_limit; end
  def rate_limit=(*arguments, &block); end
  def set_rate_limit(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::FileMonitorEvent < GLib::Enum
end
class Gio::FileMonitorFlags < GLib::Flags
  def none?; end
  def send_moved?; end
  def watch_hard_links?; end
  def watch_mounts?; end
  def watch_moves?; end
end
class Gio::FileOutputStream < Gio::OutputStream
  def etag(*arguments, &block); end
  def parent_instance; end
  def priv; end
  def query_info(*arguments, &block); end
  def query_info_async(*arguments, &block); end
  def query_info_finish(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::FileQueryInfoFlags < GLib::Flags
  def nofollow_symlinks?; end
  def none?; end
end
class Gio::FileType < GLib::Enum
end
class Gio::FilenameCompleter < GLib::Object
  def dirs_only=(*arguments, &block); end
  def get_completion_suffix(*arguments, &block); end
  def get_completions(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def set_dirs_only(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::FilesystemPreviewType < GLib::Enum
end
class Gio::IOExtension
  def name(*arguments, &block); end
  def priority(*arguments, &block); end
  def type(*arguments, &block); end
end
class Gio::IOExtensionPoint
  def extensions(*arguments, &block); end
  def get_extension_by_name(*arguments, &block); end
  def required_type(*arguments, &block); end
  def required_type=(*arguments, &block); end
  def self.implement(*arguments, &block); end
  def self.lookup(*arguments, &block); end
  def self.register(*arguments, &block); end
  def set_required_type(*arguments, &block); end
end
class Gio::IOModule < GLib::TypeModule
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def load(*arguments, &block); end
  def self.query(*arguments, &block); end
  def unload(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::IOModuleScope
  def block(*arguments, &block); end
  def free(*arguments, &block); end
end
class Gio::IOModuleScopeFlags < GLib::Enum
end
class Gio::IOSchedulerJob
  def send_to_mainloop(*arguments, &block); end
  def send_to_mainloop_async(*arguments, &block); end
end
class Gio::IOStreamSpliceFlags < GLib::Flags
  def close_stream1?; end
  def close_stream2?; end
  def none?; end
  def wait_for_both?; end
end
class Gio::InetAddressMask < GLib::Object
  def ==(*arguments, &block); end
  def address(*arguments, &block); end
  def address=(val); end
  def family(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def initialize_new_from_string(*arguments, &block); end
  def inspect; end
  def length(*arguments, &block); end
  def length=(val); end
  def matches(*arguments, &block); end
  def parent_instance; end
  def priv; end
  def set_address(val); end
  def set_length(val); end
  def to_s(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::SocketAddress < GLib::Object
  def family(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new_from_native(*arguments, &block); end
  def native_size(*arguments, &block); end
  def parent_instance; end
  def to_native(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::InetSocketAddress < Gio::SocketAddress
  def address(*arguments, &block); end
  def flowinfo(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def initialize_new_from_string(*arguments, &block); end
  def parent_instance; end
  def port(*arguments, &block); end
  def priv; end
  def scope_id(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::InputMessage
  def address; end
  def address=(value); end
  def bytes_received; end
  def bytes_received=(value); end
  def control_messages; end
  def control_messages=(value); end
  def flags; end
  def flags=(value); end
  def num_control_messages; end
  def num_control_messages=(value); end
  def num_vectors; end
  def num_vectors=(value); end
  def vectors; end
  def vectors=(value); end
end
class Gio::InputVector
  def buffer; end
  def buffer=(value); end
  def size; end
  def size=(value); end
end
class Gio::ListStore < GLib::Object
  def append(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def insert(*arguments, &block); end
  def insert_sorted(*arguments, &block); end
  def item_type; end
  def remove(*arguments, &block); end
  def remove_all(*arguments, &block); end
  def sort(*arguments, &block); end
  def splice(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::MemoryInputStream < Gio::InputStream
  def add_bytes(*arguments, &block); end
  def add_data(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def initialize_new_from_bytes(*arguments, &block); end
  def initialize_new_from_data(*arguments, &block); end
  def parent_instance; end
  def priv; end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::MemoryOutputStream < Gio::OutputStream
  def data(*arguments, &block); end
  def data_size(*arguments, &block); end
  def destroy_function; end
  def initialize(*arguments, &block); end
  def initialize_new_resizable(*arguments, &block); end
  def parent_instance; end
  def priv; end
  def realloc_function; end
  def size(*arguments, &block); end
  def steal_as_bytes(*arguments, &block); end
  def steal_data(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::Menu < Gio::MenuModel
  def append(*arguments, &block); end
  def append_item(*arguments, &block); end
  def append_section(*arguments, &block); end
  def append_submenu(*arguments, &block); end
  def freeze(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def insert(*arguments, &block); end
  def insert_item(*arguments, &block); end
  def insert_section(*arguments, &block); end
  def insert_submenu(*arguments, &block); end
  def prepend(*arguments, &block); end
  def prepend_item(*arguments, &block); end
  def prepend_section(*arguments, &block); end
  def prepend_submenu(*arguments, &block); end
  def remove(*arguments, &block); end
  def remove_all(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::MenuAttributeIter < GLib::Object
  def name(*arguments, &block); end
  def next(*arguments, &block); end
  def parent_instance; end
  def priv; end
  def value(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::MenuLinkIter < GLib::Object
  def name(*arguments, &block); end
  def next(*arguments, &block); end
  def parent_instance; end
  def priv; end
  def value(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::MountMountFlags < GLib::Flags
  def none?; end
end
class Gio::MountOperation < GLib::Object
  def anonymous=(*arguments, &block); end
  def anonymous?(*arguments, &block); end
  def choice(*arguments, &block); end
  def choice=(*arguments, &block); end
  def domain(*arguments, &block); end
  def domain=(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def parent_instance; end
  def password(*arguments, &block); end
  def password=(*arguments, &block); end
  def password_save(*arguments, &block); end
  def password_save=(*arguments, &block); end
  def priv; end
  def reply(*arguments, &block); end
  def set_anonymous(*arguments, &block); end
  def set_choice(*arguments, &block); end
  def set_domain(*arguments, &block); end
  def set_password(*arguments, &block); end
  def set_password_save(*arguments, &block); end
  def set_username(*arguments, &block); end
  def username(*arguments, &block); end
  def username=(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::MountOperationResult < GLib::Enum
end
class Gio::MountUnmountFlags < GLib::Flags
  def force?; end
  def none?; end
end
class Gio::VolumeMonitor < GLib::Object
  def connected_drives(*arguments, &block); end
  def get_mount_for_uuid(*arguments, &block); end
  def get_volume_for_uuid(*arguments, &block); end
  def mounts(*arguments, &block); end
  def parent_instance; end
  def priv; end
  def self.adopt_orphan_mount(*arguments, &block); end
  def self.get(*arguments, &block); end
  def volumes(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::NativeVolumeMonitor < Gio::VolumeMonitor
  def parent_instance; end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::NetworkAddress < GLib::Object
  def hostname(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def initialize_new_loopback(*arguments, &block); end
  def parent_instance; end
  def port(*arguments, &block); end
  def priv; end
  def scheme(*arguments, &block); end
  def self.parse(*arguments, &block); end
  def self.parse_uri(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::NetworkConnectivity < GLib::Enum
end
class Gio::NetworkService < GLib::Object
  def domain(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def parent_instance; end
  def priv; end
  def protocol(*arguments, &block); end
  def scheme(*arguments, &block); end
  def scheme=(*arguments, &block); end
  def service(*arguments, &block); end
  def set_scheme(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::Notification < GLib::Object
  def add_button(*arguments, &block); end
  def add_button_with_target(*arguments, &block); end
  def body=(*arguments, &block); end
  def default_action=(*arguments, &block); end
  def icon=(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def priority=(*arguments, &block); end
  def set_body(*arguments, &block); end
  def set_default_action(*arguments, &block); end
  def set_default_action_and_target(*arguments, &block); end
  def set_icon(*arguments, &block); end
  def set_priority(*arguments, &block); end
  def set_title(*arguments, &block); end
  def set_urgent(*arguments, &block); end
  def title=(*arguments, &block); end
  def urgent=(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::NotificationPriority < GLib::Enum
end
class Gio::OutputMessage
  def address; end
  def address=(value); end
  def bytes_sent; end
  def bytes_sent=(value); end
  def control_messages; end
  def control_messages=(value); end
  def num_control_messages; end
  def num_control_messages=(value); end
  def num_vectors; end
  def num_vectors=(value); end
  def vectors; end
  def vectors=(value); end
end
class Gio::OutputStreamSpliceFlags < GLib::Flags
  def close_source?; end
  def close_target?; end
  def none?; end
end
class Gio::OutputVector
  def buffer; end
  def buffer=(value); end
  def size; end
  def size=(value); end
end
class Gio::PasswordSave < GLib::Enum
end
class Gio::Permission < GLib::Object
  def acquire(*arguments, &block); end
  def acquire_async(*arguments, &block); end
  def acquire_finish(*arguments, &block); end
  def allowed?(*arguments, &block); end
  def can_acquire?(*arguments, &block); end
  def can_release?(*arguments, &block); end
  def impl_update(*arguments, &block); end
  def parent_instance; end
  def priv; end
  def release(*arguments, &block); end
  def release_async(*arguments, &block); end
  def release_finish(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::PropertyAction < GLib::Object
  def enabled?; end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def invert_boolean?; end
  def name; end
  def parameter_type; end
  def state; end
  def state_type; end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::ProxyAddress < Gio::InetSocketAddress
  def destination_hostname(*arguments, &block); end
  def destination_port(*arguments, &block); end
  def destination_protocol(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def parent_instance; end
  def password(*arguments, &block); end
  def priv; end
  def protocol(*arguments, &block); end
  def uri(*arguments, &block); end
  def username(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::SocketAddressEnumerator < GLib::Object
  def next(*arguments, &block); end
  def next_async(*arguments, &block); end
  def next_finish(*arguments, &block); end
  def parent_instance; end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::ProxyAddressEnumerator < Gio::SocketAddressEnumerator
  def connectable; end
  def default_port; end
  def parent_instance; end
  def priv; end
  def proxy_resolver; end
  def proxy_resolver=(val); end
  def set_proxy_resolver(val); end
  def uri; end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::Resolver < GLib::Object
  def lookup_by_address(*arguments, &block); end
  def lookup_by_address_async(*arguments, &block); end
  def lookup_by_address_finish(*arguments, &block); end
  def lookup_by_name(*arguments, &block); end
  def lookup_by_name_async(*arguments, &block); end
  def lookup_by_name_finish(*arguments, &block); end
  def lookup_records(*arguments, &block); end
  def lookup_records_async(*arguments, &block); end
  def lookup_records_finish(*arguments, &block); end
  def lookup_service(*arguments, &block); end
  def lookup_service_async(*arguments, &block); end
  def lookup_service_finish(*arguments, &block); end
  def parent_instance; end
  def priv; end
  def self.default(*arguments, &block); end
  def set_default(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::ResolverRecordType < GLib::Enum
end
class Gio::Resource < GLib::Boxed
  def _register(*arguments, &block); end
  def _unregister(*arguments, &block); end
  def enumerate_children(*arguments, &block); end
  def get_info(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new_from_data(*arguments, &block); end
  def lookup_data(*arguments, &block); end
  def open_stream(*arguments, &block); end
  def ref(*arguments, &block); end
  def self.load(*arguments, &block); end
  def unref(*arguments, &block); end
end
class Gio::ResourceFlags < GLib::Flags
  def compressed?; end
  def none?; end
end
class Gio::ResourceLookupFlags < GLib::Flags
  def none?; end
end
class Gio::SettingsBackend < GLib::Object
  def changed(*arguments, &block); end
  def changed_tree(*arguments, &block); end
  def keys_changed(*arguments, &block); end
  def parent_instance; end
  def path_changed(*arguments, &block); end
  def path_writable_changed(*arguments, &block); end
  def priv; end
  def self.default(*arguments, &block); end
  def self.flatten_tree(*arguments, &block); end
  def writable_changed(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::SettingsBindFlags < GLib::Flags
  def default?; end
  def get?; end
  def get_no_changes?; end
  def invert_boolean?; end
  def no_sensitivity?; end
  def set?; end
end
class Gio::SettingsSchema < GLib::Boxed
  def children(*arguments, &block); end
  def get_key(*arguments, &block); end
  def has_key?(*arguments, &block); end
  def id(*arguments, &block); end
  def keys(*arguments, &block); end
  def path(*arguments, &block); end
  def ref(*arguments, &block); end
  def unref(*arguments, &block); end
end
class Gio::SettingsSchemaKey < GLib::Boxed
  def default_value(*arguments, &block); end
  def description(*arguments, &block); end
  def name(*arguments, &block); end
  def range(*arguments, &block); end
  def range_check(*arguments, &block); end
  def ref(*arguments, &block); end
  def summary(*arguments, &block); end
  def unref(*arguments, &block); end
  def value_type(*arguments, &block); end
end
class Gio::SimpleActionGroup < GLib::Object
  def add_entries(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def insert(*arguments, &block); end
  def lookup(*arguments, &block); end
  def parent_instance; end
  def priv; end
  def remove(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::SimpleAsyncResult < GLib::Object
  def check_cancellable=(*arguments, &block); end
  def complete(*arguments, &block); end
  def complete_in_idle(*arguments, &block); end
  def from_error=(*arguments, &block); end
  def handle_cancellation=(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def initialize_new_from_error(*arguments, &block); end
  def op_res_gboolean=(*arguments, &block); end
  def op_res_gboolean?(*arguments, &block); end
  def op_res_gssize(*arguments, &block); end
  def op_res_gssize=(*arguments, &block); end
  def propagate_error(*arguments, &block); end
  def self.valid?(*arguments, &block); end
  def set_check_cancellable(*arguments, &block); end
  def set_from_error(*arguments, &block); end
  def set_handle_cancellation(*arguments, &block); end
  def set_op_res_gboolean(*arguments, &block); end
  def set_op_res_gssize(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::SimpleIOStream < Gio::IOStream
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def input_stream; end
  def output_stream; end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::SimplePermission < Gio::Permission
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::SimpleProxyResolver < GLib::Object
  def default_proxy; end
  def default_proxy=(*arguments, &block); end
  def ignore_hosts; end
  def ignore_hosts=(*arguments, &block); end
  def parent_instance; end
  def priv; end
  def set_default_proxy(*arguments, &block); end
  def set_ignore_hosts(*arguments, &block); end
  def set_uri_proxy(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::Socket < GLib::Object
  def accept(*arguments, &block); end
  def available_bytes(*arguments, &block); end
  def bind(*arguments, &block); end
  def blocking=(*arguments, &block); end
  def blocking?(*arguments, &block); end
  def broadcast=(*arguments, &block); end
  def broadcast?(*arguments, &block); end
  def check_connect_result(*arguments, &block); end
  def close(*arguments, &block); end
  def closed?(*arguments, &block); end
  def condition_check(*arguments, &block); end
  def condition_timed_wait(*arguments, &block); end
  def condition_wait(*arguments, &block); end
  def connect(*arguments, &block); end
  def connected?(*arguments, &block); end
  def connection_factory_create_connection(*arguments, &block); end
  def credentials(*arguments, &block); end
  def family(*arguments, &block); end
  def fd(*arguments, &block); end
  def get_option(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def initialize_new_from_fd(*arguments, &block); end
  def join_multicast_group(*arguments, &block); end
  def join_multicast_group_ssm(*arguments, &block); end
  def keepalive=(*arguments, &block); end
  def keepalive?(*arguments, &block); end
  def leave_multicast_group(*arguments, &block); end
  def leave_multicast_group_ssm(*arguments, &block); end
  def listen(*arguments, &block); end
  def listen_backlog(*arguments, &block); end
  def listen_backlog=(*arguments, &block); end
  def local_address(*arguments, &block); end
  def multicast_loopback=(*arguments, &block); end
  def multicast_loopback?(*arguments, &block); end
  def multicast_ttl(*arguments, &block); end
  def multicast_ttl=(*arguments, &block); end
  def parent_instance; end
  def priv; end
  def protocol(*arguments, &block); end
  def receive(*arguments, &block); end
  def receive_from(*arguments, &block); end
  def receive_message(*arguments, &block); end
  def receive_messages(*arguments, &block); end
  def receive_with_blocking(*arguments, &block); end
  def remote_address(*arguments, &block); end
  def send(*arguments, &block); end
  def send_message(*arguments, &block); end
  def send_messages(*arguments, &block); end
  def send_to(*arguments, &block); end
  def send_with_blocking(*arguments, &block); end
  def set_blocking(*arguments, &block); end
  def set_broadcast(*arguments, &block); end
  def set_keepalive(*arguments, &block); end
  def set_listen_backlog(*arguments, &block); end
  def set_multicast_loopback(*arguments, &block); end
  def set_multicast_ttl(*arguments, &block); end
  def set_option(*arguments, &block); end
  def set_timeout(*arguments, &block); end
  def set_ttl(*arguments, &block); end
  def shutdown(*arguments, &block); end
  def socket_type(*arguments, &block); end
  def speaks_ipv4(*arguments, &block); end
  def timeout(*arguments, &block); end
  def timeout=(*arguments, &block); end
  def ttl(*arguments, &block); end
  def ttl=(*arguments, &block); end
  def type; end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::SocketClient < GLib::Object
  def add_application_proxy(*arguments, &block); end
  def connect(*arguments, &block); end
  def connect_async(*arguments, &block); end
  def connect_finish(*arguments, &block); end
  def connect_to_host(*arguments, &block); end
  def connect_to_host_async(*arguments, &block); end
  def connect_to_host_finish(*arguments, &block); end
  def connect_to_service(*arguments, &block); end
  def connect_to_service_async(*arguments, &block); end
  def connect_to_service_finish(*arguments, &block); end
  def connect_to_uri(*arguments, &block); end
  def connect_to_uri_async(*arguments, &block); end
  def connect_to_uri_finish(*arguments, &block); end
  def enable_proxy=(*arguments, &block); end
  def enable_proxy?(*arguments, &block); end
  def family(*arguments, &block); end
  def family=(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def local_address(*arguments, &block); end
  def local_address=(*arguments, &block); end
  def parent_instance; end
  def priv; end
  def protocol(*arguments, &block); end
  def protocol=(*arguments, &block); end
  def proxy_resolver(*arguments, &block); end
  def proxy_resolver=(*arguments, &block); end
  def set_enable_proxy(*arguments, &block); end
  def set_family(*arguments, &block); end
  def set_local_address(*arguments, &block); end
  def set_protocol(*arguments, &block); end
  def set_proxy_resolver(*arguments, &block); end
  def set_socket_type(*arguments, &block); end
  def set_timeout(*arguments, &block); end
  def set_tls(*arguments, &block); end
  def set_tls_validation_flags(*arguments, &block); end
  def set_type(val); end
  def socket_type(*arguments, &block); end
  def socket_type=(*arguments, &block); end
  def timeout(*arguments, &block); end
  def timeout=(*arguments, &block); end
  def tls=(*arguments, &block); end
  def tls?(*arguments, &block); end
  def tls_validation_flags(*arguments, &block); end
  def tls_validation_flags=(*arguments, &block); end
  def type; end
  def type=(val); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::SocketClientEvent < GLib::Enum
end
class Gio::SocketConnection < Gio::IOStream
  def connect(*arguments, &block); end
  def connect_async(*arguments, &block); end
  def connect_finish(*arguments, &block); end
  def connected?(*arguments, &block); end
  def local_address(*arguments, &block); end
  def parent_instance; end
  def priv; end
  def remote_address(*arguments, &block); end
  def self.factory_lookup_type(*arguments, &block); end
  def self.factory_register_type(*arguments, &block); end
  def socket(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::SocketControlMessage < GLib::Object
  def level(*arguments, &block); end
  def msg_type(*arguments, &block); end
  def parent_instance; end
  def priv; end
  def self.deserialize(*arguments, &block); end
  def serialize(*arguments, &block); end
  def size(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::SocketFamily < GLib::Enum
end
class Gio::SocketListener < GLib::Object
  def accept(*arguments, &block); end
  def accept_async(*arguments, &block); end
  def accept_finish(*arguments, &block); end
  def accept_socket(*arguments, &block); end
  def accept_socket_async(*arguments, &block); end
  def accept_socket_finish(*arguments, &block); end
  def add_address(*arguments, &block); end
  def add_any_inet_port(*arguments, &block); end
  def add_inet_port(*arguments, &block); end
  def add_socket(*arguments, &block); end
  def backlog=(*arguments, &block); end
  def close(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def listen_backlog; end
  def listen_backlog=(val); end
  def parent_instance; end
  def priv; end
  def set_backlog(*arguments, &block); end
  def set_listen_backlog(val); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::SocketListenerEvent < GLib::Enum
end
class Gio::SocketMsgFlags < GLib::Flags
  def dontroute?; end
  def none?; end
  def oob?; end
  def peek?; end
end
class Gio::SocketProtocol < GLib::Enum
end
class Gio::SocketService < Gio::SocketListener
  def active=(val); end
  def active?(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def parent_instance; end
  def priv; end
  def set_active(val); end
  def start(*arguments, &block); end
  def stop(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::SocketType < GLib::Enum
end
class Gio::SrvTarget < GLib::Boxed
  def copy(*arguments, &block); end
  def free(*arguments, &block); end
  def hostname(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def port(*arguments, &block); end
  def priority(*arguments, &block); end
  def weight(*arguments, &block); end
end
class Gio::StaticResource
  def data; end
  def data_len; end
  def fini(*arguments, &block); end
  def init(*arguments, &block); end
  def next; end
  def padding; end
  def resource(*arguments, &block); end
end
class Gio::Subprocess < GLib::Object
  def communicate(*arguments, &block); end
  def communicate_async(*arguments, &block); end
  def communicate_finish(*arguments, &block); end
  def communicate_utf8(*arguments, &block); end
  def communicate_utf8_async(*arguments, &block); end
  def communicate_utf8_finish(*arguments, &block); end
  def exit_status(*arguments, &block); end
  def force_exit(*arguments, &block); end
  def identifier(*arguments, &block); end
  def if_exited?(*arguments, &block); end
  def if_signaled?(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def send_signal(*arguments, &block); end
  def status(*arguments, &block); end
  def stderr_pipe(*arguments, &block); end
  def stdin_pipe(*arguments, &block); end
  def stdout_pipe(*arguments, &block); end
  def successful?(*arguments, &block); end
  def term_sig(*arguments, &block); end
  def wait(*arguments, &block); end
  def wait_async(*arguments, &block); end
  def wait_check(*arguments, &block); end
  def wait_check_async(*arguments, &block); end
  def wait_check_finish(*arguments, &block); end
  def wait_finish(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::SubprocessFlags < GLib::Flags
  def inherit_fds?; end
  def none?; end
  def stderr_merge?; end
  def stderr_pipe?; end
  def stderr_silence?; end
  def stdin_inherit?; end
  def stdin_pipe?; end
  def stdout_pipe?; end
  def stdout_silence?; end
end
class Gio::SubprocessLauncher < GLib::Object
  def cwd=(*arguments, &block); end
  def environ=(*arguments, &block); end
  def flags=(*arguments, &block); end
  def getenv(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def set_cwd(*arguments, &block); end
  def set_environ(*arguments, &block); end
  def set_flags(*arguments, &block); end
  def set_stderr_file_path(*arguments, &block); end
  def set_stdin_file_path(*arguments, &block); end
  def set_stdout_file_path(*arguments, &block); end
  def setenv(*arguments, &block); end
  def spawnv(*arguments, &block); end
  def stderr_file_path=(*arguments, &block); end
  def stdin_file_path=(*arguments, &block); end
  def stdout_file_path=(*arguments, &block); end
  def take_fd(*arguments, &block); end
  def take_stderr_fd(*arguments, &block); end
  def take_stdin_fd(*arguments, &block); end
  def take_stdout_fd(*arguments, &block); end
  def unsetenv(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::Task < GLib::Object
  def cancellable(*arguments, &block); end
  def check_cancellable=(*arguments, &block); end
  def check_cancellable?(*arguments, &block); end
  def completed?(*arguments, &block); end
  def context(*arguments, &block); end
  def had_error(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def priority(*arguments, &block); end
  def priority=(*arguments, &block); end
  def propagate_boolean(*arguments, &block); end
  def propagate_int(*arguments, &block); end
  def propagate_pointer(*arguments, &block); end
  def return_boolean(*arguments, &block); end
  def return_error(*arguments, &block); end
  def return_error_if_cancelled(*arguments, &block); end
  def return_int(*arguments, &block); end
  def return_on_cancel=(*arguments, &block); end
  def return_on_cancel?(*arguments, &block); end
  def return_pointer(*arguments, &block); end
  def self.report_error(*arguments, &block); end
  def self.valid?(*arguments, &block); end
  def set_check_cancellable(*arguments, &block); end
  def set_priority(*arguments, &block); end
  def set_return_on_cancel(*arguments, &block); end
  def set_source_tag(*arguments, &block); end
  def set_task_data(*arguments, &block); end
  def source_object(*arguments, &block); end
  def source_tag(*arguments, &block); end
  def source_tag=(*arguments, &block); end
  def task_data(*arguments, &block); end
  def task_data=(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::TcpConnection < Gio::SocketConnection
  def graceful_disconnect=(*arguments, &block); end
  def graceful_disconnect?(*arguments, &block); end
  def parent_instance; end
  def priv; end
  def set_graceful_disconnect(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::TcpWrapperConnection < Gio::TcpConnection
  def base_io_stream(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def parent_instance; end
  def priv; end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::TestDBus < GLib::Object
  def add_service_dir(*arguments, &block); end
  def bus_address(*arguments, &block); end
  def down(*arguments, &block); end
  def flags(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def self.unset(*arguments, &block); end
  def stop(*arguments, &block); end
  def up(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::TestDBusFlags < GLib::Flags
  def none?; end
end
class Gio::ThemedIcon < GLib::Object
  def append_name(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def initialize_new_from_names(*arguments, &block); end
  def initialize_new_with_default_fallbacks(*arguments, &block); end
  def names(*arguments, &block); end
  def prepend_name(*arguments, &block); end
  def use_default_fallbacks?; end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::ThreadedSocketService < Gio::SocketService
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def max_threads; end
  def parent_instance; end
  def priv; end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::TlsAuthenticationMode < GLib::Enum
end
class Gio::TlsCertificate < GLib::Object
  def certificate; end
  def certificate_pem; end
  def initialize(*arguments, &block); end
  def initialize_new_from_file(*arguments, &block); end
  def initialize_new_from_files(*arguments, &block); end
  def initialize_new_from_pem(*arguments, &block); end
  def issuer(*arguments, &block); end
  def parent_instance; end
  def priv; end
  def same?(*arguments, &block); end
  def self.list_new_from_file(*arguments, &block); end
  def verify(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::TlsCertificateFlags < GLib::Flags
  def bad_identity?; end
  def expired?; end
  def generic_error?; end
  def insecure?; end
  def not_activated?; end
  def revoked?; end
  def unknown_ca?; end
  def validate_all?; end
end
class Gio::TlsCertificateRequestFlags < GLib::Enum
end
class Gio::TlsConnection < Gio::IOStream
  def base_io_stream; end
  def certificate(*arguments, &block); end
  def certificate=(*arguments, &block); end
  def database(*arguments, &block); end
  def database=(*arguments, &block); end
  def emit_accept_certificate(*arguments, &block); end
  def handshake(*arguments, &block); end
  def handshake_async(*arguments, &block); end
  def handshake_finish(*arguments, &block); end
  def interaction(*arguments, &block); end
  def interaction=(*arguments, &block); end
  def parent_instance; end
  def peer_certificate(*arguments, &block); end
  def peer_certificate_errors(*arguments, &block); end
  def priv; end
  def rehandshake_mode(*arguments, &block); end
  def rehandshake_mode=(*arguments, &block); end
  def require_close_notify=(*arguments, &block); end
  def require_close_notify?(*arguments, &block); end
  def set_certificate(*arguments, &block); end
  def set_database(*arguments, &block); end
  def set_interaction(*arguments, &block); end
  def set_rehandshake_mode(*arguments, &block); end
  def set_require_close_notify(*arguments, &block); end
  def set_use_system_certdb(*arguments, &block); end
  def use_system_certdb=(*arguments, &block); end
  def use_system_certdb?(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::TlsDatabase < GLib::Object
  def create_certificate_handle(*arguments, &block); end
  def lookup_certificate_for_handle(*arguments, &block); end
  def lookup_certificate_for_handle_async(*arguments, &block); end
  def lookup_certificate_for_handle_finish(*arguments, &block); end
  def lookup_certificate_issuer(*arguments, &block); end
  def lookup_certificate_issuer_async(*arguments, &block); end
  def lookup_certificate_issuer_finish(*arguments, &block); end
  def lookup_certificates_issued_by(*arguments, &block); end
  def lookup_certificates_issued_by_async(*arguments, &block); end
  def lookup_certificates_issued_by_finish(*arguments, &block); end
  def parent_instance; end
  def priv; end
  def verify_chain(*arguments, &block); end
  def verify_chain_async(*arguments, &block); end
  def verify_chain_finish(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::TlsDatabaseLookupFlags < GLib::Enum
end
class Gio::TlsDatabaseVerifyFlags < GLib::Flags
  def none?; end
end
class Gio::TlsInteraction < GLib::Object
  def ask_password(*arguments, &block); end
  def ask_password_async(*arguments, &block); end
  def ask_password_finish(*arguments, &block); end
  def invoke_ask_password(*arguments, &block); end
  def invoke_request_certificate(*arguments, &block); end
  def parent_instance; end
  def priv; end
  def request_certificate(*arguments, &block); end
  def request_certificate_async(*arguments, &block); end
  def request_certificate_finish(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::TlsInteractionResult < GLib::Enum
end
class Gio::TlsPassword < GLib::Object
  def description(*arguments, &block); end
  def description=(*arguments, &block); end
  def flags(*arguments, &block); end
  def flags=(*arguments, &block); end
  def get_value(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def parent_instance; end
  def priv; end
  def set_description(*arguments, &block); end
  def set_flags(*arguments, &block); end
  def set_value(*arguments, &block); end
  def set_value_full(*arguments, &block); end
  def set_warning(*arguments, &block); end
  def value=(*arguments, &block); end
  def value_full=(*arguments, &block); end
  def warning(*arguments, &block); end
  def warning=(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::TlsPasswordFlags < GLib::Flags
  def final_try?; end
  def many_tries?; end
  def none?; end
  def retry?; end
end
class Gio::TlsRehandshakeMode < GLib::Enum
end
class Gio::UnixConnection < Gio::SocketConnection
  def parent_instance; end
  def priv; end
  def receive_credentials(*arguments, &block); end
  def receive_credentials_async(*arguments, &block); end
  def receive_credentials_finish(*arguments, &block); end
  def receive_fd(*arguments, &block); end
  def send_credentials(*arguments, &block); end
  def send_credentials_async(*arguments, &block); end
  def send_credentials_finish(*arguments, &block); end
  def send_fd(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::UnixCredentialsMessage < Gio::SocketControlMessage
  def credentials(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def initialize_new_with_credentials(*arguments, &block); end
  def parent_instance; end
  def priv; end
  def self.supported?(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::UnixFDList < GLib::Object
  def append(*arguments, &block); end
  def get(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def initialize_new_from_array(*arguments, &block); end
  def length(*arguments, &block); end
  def parent_instance; end
  def peek_fds(*arguments, &block); end
  def priv; end
  def steal_fds(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::UnixFDMessage < Gio::SocketControlMessage
  def append_fd(*arguments, &block); end
  def fd_list(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def initialize_new_with_fd_list(*arguments, &block); end
  def parent_instance; end
  def priv; end
  def steal_fds(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::UnixInputStream < Gio::InputStream
  def close_fd=(*arguments, &block); end
  def close_fd?(*arguments, &block); end
  def fd(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def parent_instance; end
  def priv; end
  def set_close_fd(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::UnixMountEntry < GLib::Boxed
end
class Gio::UnixMountMonitor < GLib::Object
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def rate_limit=(*arguments, &block); end
  def self.get(*arguments, &block); end
  def set_rate_limit(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::UnixMountPoint < GLib::Boxed
  def compare(*arguments, &block); end
  def copy(*arguments, &block); end
  def device_path(*arguments, &block); end
  def free(*arguments, &block); end
  def fs_type(*arguments, &block); end
  def guess_can_eject(*arguments, &block); end
  def guess_icon(*arguments, &block); end
  def guess_name(*arguments, &block); end
  def guess_symbolic_icon(*arguments, &block); end
  def loopback?(*arguments, &block); end
  def mount_path(*arguments, &block); end
  def options(*arguments, &block); end
  def readonly?(*arguments, &block); end
  def user_mountable?(*arguments, &block); end
end
class Gio::UnixOutputStream < Gio::OutputStream
  def close_fd=(*arguments, &block); end
  def close_fd?(*arguments, &block); end
  def fd(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def parent_instance; end
  def priv; end
  def set_close_fd(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::UnixSocketAddress < Gio::SocketAddress
  def abstract?(*arguments, &block); end
  def address_type(*arguments, &block); end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def initialize_new_abstract(*arguments, &block); end
  def initialize_new_with_type(*arguments, &block); end
  def parent_instance; end
  def path(*arguments, &block); end
  def path_as_array; end
  def path_len(*arguments, &block); end
  def priv; end
  def self.abstract_names_supported(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::UnixSocketAddressType < GLib::Enum
end
class Gio::Vfs < GLib::Object
  def active?(*arguments, &block); end
  def get_file_for_path(*arguments, &block); end
  def get_file_for_uri(*arguments, &block); end
  def parent_instance; end
  def parse_name(*arguments, &block); end
  def register_uri_scheme(*arguments, &block); end
  def self.default(*arguments, &block); end
  def self.local(*arguments, &block); end
  def supported_uri_schemes(*arguments, &block); end
  def unregister_uri_scheme(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::ZlibCompressor < GLib::Object
  def file_info(*arguments, &block); end
  def file_info=(*arguments, &block); end
  def format; end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  def level; end
  def set_file_info(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
class Gio::ZlibCompressorFormat < GLib::Enum
end
class Gio::ZlibDecompressor < GLib::Object
  def file_info(*arguments, &block); end
  def format; end
  def initialize(*arguments, &block); end
  def initialize_new(*arguments, &block); end
  extend GObjectIntrospection::Loader::VirtualFunctionImplementable
end
