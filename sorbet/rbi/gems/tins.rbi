# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/tins/all/tins.rbi
#
# tins-1.29.1

module Tins
end
module Tins::Blank
end
module Tins::Blank::Object
  def blank?; end
  def present?; end
end
module Tins::Blank::NilClass
  def blank?; end
end
module Tins::Blank::FalseClass
  def blank?; end
end
module Tins::Blank::TrueClass
  def blank?; end
end
module Tins::Blank::Array
  def self.included(modul); end
end
module Tins::Blank::Hash
  def self.included(modul); end
end
module Tins::Blank::String
  def blank?; end
end
module Tins::Blank::Numeric
  def blank?; end
end
module Tins::Full
  def all_full?; end
  def full?(dispatch = nil, *args); end
end
class Object < BasicObject
  include Tins::Full
end
module Tins::Terminal
  def cols; end
  def columns; end
  def lines; end
  def rows; end
  def self.cols; end
  def self.columns; end
  def self.lines; end
  def self.rows; end
  def self.winsize; end
  def winsize; end
end
module Tins::Attempt
  def attempt(opts = nil, &block); end
  def compute_duration_base(sleep, attempts); end
  def interpret_sleep(sleep, attempts); end
  def sleep_duration(duration, count); end
end
class Tins::Bijection < Hash
  def []=(key, value); end
  def fill; end
  def freeze; end
  def initialize(inverted = nil); end
  def inverted; end
  def self.[](*pairs); end
end
module Tins::CountBy
  def count_by(&b); end
end
module Tins::DeepDup
  def deep_dup; end
end
module Tins::FileBinary
  def ascii?(options = nil); end
  def binary?(options = nil); end
  def self.default_options; end
  def self.default_options=(arg0); end
  def self.included(modul); end
end
module Tins::FileBinary::Constants
end
module Tins::FileBinary::ClassMethods
  def ascii?(name, options = nil); end
  def binary?(name, options = nil); end
end
module Tins::ModuleGroup
  def self.[](*modules); end
end
module Tins::Find
  def find(*paths, &block); end
  def prune; end
  def self.find(*paths, &block); end
  def self.prune; end
end
module Tins::Find::EXPECTED_STANDARD_ERRORS
end
class Errno::ENOENT < SystemCallError
  include Tins::Find::EXPECTED_STANDARD_ERRORS
end
class Errno::EACCES < SystemCallError
  include Tins::Find::EXPECTED_STANDARD_ERRORS
end
class Errno::ENOTDIR < SystemCallError
  include Tins::Find::EXPECTED_STANDARD_ERRORS
end
class Errno::ELOOP < SystemCallError
  include Tins::Find::EXPECTED_STANDARD_ERRORS
end
class Errno::ENAMETOOLONG < SystemCallError
  include Tins::Find::EXPECTED_STANDARD_ERRORS
end
class Tins::Find::Finder
  def find(*paths); end
  def follow_symlinks; end
  def follow_symlinks=(arg0); end
  def initialize(opts = nil); end
  def prepare_path(path); end
  def protect_from_errors(errors = nil); end
  def raise_errors; end
  def raise_errors=(arg0); end
  def show_hidden; end
  def show_hidden=(arg0); end
  def suffix; end
  def suffix=(arg0); end
  def visit_path?(path); end
end
module Tins::Find::Finder::PathExtension
  def directory?; end
  def exist?; end
  def file; end
  def file?; end
  def finder; end
  def finder=(arg0); end
  def finder_stat; end
  def lstat; end
  def pathname; end
  def stat; end
  def suffix; end
end
class Tins::Generator
  def add_dimension(enum, iterator = nil); end
  def each(&block); end
  def initialize(enums); end
  def recurse(tuple = nil, i = nil, &block); end
  def self.[](*enums); end
  def size; end
  include Enumerable
end
module Tins::GO
  def go(s, args = nil, defaults: nil); end
  def self.go(s, args = nil, defaults: nil); end
end
module Tins::GO::EnumerableExtension
  def <<(argument); end
  def each(&block); end
  def push(argument); end
  include Enumerable
end
module Tins::ThreadLocal
  def instance_thread_local(name, default_value = nil, &default); end
  def thread_local(name, default_value = nil, &default); end
end
module Tins::HashSymbolizeKeysRecursive
  def _symbolize_keys_recursive(object, circular: nil); end
  def seen; end
  def seen=(value); end
  def symbolize_keys_recursive!(circular: nil); end
  def symbolize_keys_recursive(circular: nil); end
  extend Tins::ThreadLocal
end
module Tins::HashUnion
  def |(other); end
end
class Tins::Limited
  def execute; end
  def initialize(maximum); end
  def maximum; end
  def process; end
  def wait; end
end
class Tins::LinesFile
  def each(&block); end
  def empty?; end
  def file_linenumber; end
  def filename; end
  def filename=(arg0); end
  def initialize(lines, line_number = nil); end
  def inspect; end
  def last_line_number; end
  def line; end
  def line_number; end
  def line_number=(number); end
  def match_backward(regexp, previous_after_match = nil); end
  def match_forward(regexp, next_after_match = nil); end
  def next!; end
  def previous!; end
  def rewind; end
  def self.for_file(file, line_number = nil); end
  def self.for_filename(filename, line_number = nil); end
  def self.for_lines(lines, line_number = nil); end
  def to_s; end
  include Enumerable
end
module Tins::LinesFile::LineExtension
  def filename; end
  def line_number; end
end
module Tins::ExtractLastArgumentOptions
  def extract_last_argument_options; end
end
module Tins::Memoize
end
module Tins::Memoize::CacheMethods
  def __memoize_cache__; end
  def memoize_apply_visibility(id); end
  def memoize_cache_clear; end
end
class Module
  def memoize_function(*function_ids); end
  def memoize_method(*method_ids); end
  include Tins::Memoize::CacheMethods
end
module Tins::Minimize
  def minimize!; end
  def minimize; end
  def unminimize!; end
  def unminimize; end
end
class Tins::NamedSet < Set
  def initialize(name); end
  def name; end
  def name=(arg0); end
end
module Tins::Null
  def as_json(*arg0); end
  def blank?; end
  def const_missing(*arg0); end
  def inspect; end
  def method_missing(*arg0); end
  def nil?; end
  def to_a; end
  def to_ary; end
  def to_f; end
  def to_i; end
  def to_int; end
  def to_json(*arg0); end
  def to_s; end
  def to_str; end
end
module Tins::Null::Kernel
  def Null(value = nil); end
  def NullPlus(opts = nil); end
  def null(value = nil); end
  def null_plus(opts = nil); end
end
class Tins::NullClass < Module
  include Tins::Null
end
module Tins::NULL
end
class Tins::NullPlus
  def initialize(opts = nil); end
  include Tins::Null
end
module Tins::Once
  def only_once(lock_filename = nil, locking_constant = nil); end
  def self.only_once(lock_filename = nil, locking_constant = nil); end
  def self.try_only_once(lock_filename = nil, locking_constant = nil, &block); end
  def try_only_once(lock_filename = nil, locking_constant = nil, &block); end
  include File::Constants
end
module Tins::P
  def p!(*objs); end
  def pp!(*objs); end
end
module Tins::PartialApplication
  def partial(*args); end
  def self.included(modul); end
end
module Tins::RangePlus
  def +(other); end
end
module Tins::RequireMaybe
  def require_maybe(library); end
end
module Tins::SecureWrite
  def secure_write(filename, content = nil, mode = nil); end
end
module Tins::StringCamelize
  def camelcase(first_letter = nil); end
  def camelize(first_letter = nil); end
end
module Tins::StringUnderscore
  def underscore; end
end
module Tins::StringVersion
  def version; end
end
class Tins::StringVersion::Version
  def <=>(other); end
  def ==(other); end
  def [](level); end
  def []=(level, value); end
  def array; end
  def build; end
  def build=(new_level); end
  def bump(level = nil); end
  def initialize(string); end
  def initialize_copy(source); end
  def inspect; end
  def level_of(specifier); end
  def major; end
  def major=(new_level); end
  def minor; end
  def minor=(new_level); end
  def pred!; end
  def revision; end
  def revision=(new_level); end
  def succ!; end
  def to_a; end
  def to_s; end
  include Comparable
end
module Tins::Subhash
  def subhash(*patterns); end
end
module Tins::TimeDummy
  def self.included(modul); end
end
module Tins::DateDummy
  def self.included(modul); end
end
module Tins::DateTimeDummy
  def self.included(modul); end
end
module Tins::ToProc
  def to_proc; end
end
module Tins::UniqBy
  def uniq_by(&b); end
end
module Tins::Write
  def self.extended(modul); end
end
module Tins::DeepConstGet
  def deep_const_get(path, start_module = nil); end
  def self.const_defined_in?(modul, constant); end
  def self.deep_const_get(path, start_module = nil); end
end
module Tins::Responding
  def responding?(*method_names); end
end
module Tins::ProcCompose
  def *(other); end
  def compose(other); end
end
module Tins::ProcPrelude
  def apply(&my_proc); end
  def array(*args); end
  def call(obj, &my_proc); end
  def const(konst = nil, &my_proc); end
  def first(*args); end
  def from(&block); end
  def head(*args); end
  def id1(*args); end
  def last(*args); end
  def map_apply(my_method, *args, &my_proc); end
  def nth(n); end
  def rotate(n = nil); end
  def second(*args); end
  def swap(n = nil); end
  def tail(*args); end
end
module Tins::Concern
  def append_features(base); end
  def included(base = nil, &block); end
  def self.extended(base); end
end
module Tins::To
  def to(string); end
end
module Tins::SexySingleton
  def _dump(depth = nil); end
  def clone; end
  def dup; end
  def self.__old_singleton_included__(klass); end
end
module Singleton::SingletonClassMethods
end
module Tins::MethodDescription
  def description(style: nil); end
  def signature; end
end
class Tins::MethodDescription::Parameters
  def self.build(type, name); end
end
class Anonymous_Struct_13 < Struct
  def name; end
  def name=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def type; end
  def type=(_); end
end
class Tins::MethodDescription::Parameters::Parameter < Anonymous_Struct_13
  def ==(other); end
  def inspect; end
end
class Tins::MethodDescription::Parameters::RestParameter < Tins::MethodDescription::Parameters::Parameter
  def to_s; end
end
class Tins::MethodDescription::Parameters::KeyrestParameter < Tins::MethodDescription::Parameters::Parameter
  def to_s; end
end
class Tins::MethodDescription::Parameters::ReqParameter < Tins::MethodDescription::Parameters::Parameter
  def to_s; end
end
class Tins::MethodDescription::Parameters::OptParameter < Tins::MethodDescription::Parameters::Parameter
  def to_s; end
end
class Tins::MethodDescription::Parameters::KeyParameter < Tins::MethodDescription::Parameters::Parameter
  def to_s; end
end
class Tins::MethodDescription::Parameters::KeyreqParameter < Tins::MethodDescription::Parameters::Parameter
  def to_s; end
end
class Tins::MethodDescription::Parameters::BlockParameter < Tins::MethodDescription::Parameters::Parameter
  def to_s; end
end
class Tins::MethodDescription::Parameters::GenericParameter < Tins::MethodDescription::Parameters::Parameter
  def to_s; end
end
class Tins::MethodDescription::Signature
  def ==(other); end
  def ===(method); end
  def eql?(other); end
  def initialize(*parameters); end
  def inspect; end
  def parameters; end
  def to_s; end
end
module Tins::Annotate
  def annotate(name); end
end
class Tins::Token < String
  def bits; end
  def bits=(arg0); end
  def initialize(bits: nil, length: nil, alphabet: nil, random: nil); end
end
module Tins::Eigenclass
  def eigenclass; end
  def eigenclass_eval(&block); end
end
module Tins::ClassMethod
  def class_attr_accessor(*ids); end
  def class_attr_reader(*ids); end
  def class_attr_writer(*ids); end
  def class_define_method(name, &block); end
  include Tins::Eigenclass
end
module Tins::ThreadGlobal
  def instance_thread_global(name, value = nil); end
  def thread_global(name, default_value = nil, &default); end
end
module Tins::InstanceExec
  def self.included(*arg0); end
end
module Tins::Interpreter
  def interpret(source, *args); end
  def interpret_with_binding(source, my_binding, *args); end
end
module Tins::Constant
  def constant(name, value = nil); end
end
module Tins::DSLAccessor
  def dsl_accessor(name, *default, &block); end
  def dsl_reader(name, *default, &block); end
end
module Tins::SymbolMaker
  def method_missing(id, *args); end
end
module Tins::ConstantMaker
  def const_missing(id); end
end
module Tins::BlankSlate
  def self.with(*ids); end
end
module Tins::Deflect
  def deflect(from, id, deflector); end
  def deflect?(from, id); end
  def deflect_start(from, id, deflector); end
  def deflect_stop(from, id); end
  def self.deflect?(from, id); end
  def self.deflecting; end
  def self.deflecting=(value); end
end
class Tins::Deflect::DeflectError < StandardError
end
class Tins::Deflect::Deflector < Proc
end
class Tins::Deflect::DeflectorCollection
  def add(klass, id, deflector); end
  def delete(klass, id); end
  def find(klass, id); end
  def initialize; end
  def member?(klass, id); end
end
module Tins::Delegate
  def delegate(method_name, opts = nil); end
end
module Tins::BlockSelf
  def block_self(&block); end
  def self.block_self(&block); end
end
module Tins::MethodMissingDelegator
  def method_missing(id, *a, &b); end
  def method_missing_delegator; end
  def method_missing_delegator=(arg0); end
end
module Tins::MethodMissingDelegator::DelegatorModule
  def initialize(delegator, *a, &b); end
  include Tins::MethodMissingDelegator
end
class Tins::MethodMissingDelegator::DelegatorClass
  include Tins::MethodMissingDelegator::DelegatorModule
end
module Tins::ParameterizedModule
  def parameterize_for(*args, &block); end
end
module Tins::FromModule
  def from(*args, &block); end
  def parameterize(opts = nil); end
  include Tins::ParameterizedModule
end
module Tins::Scope
  def scope(name = nil); end
  def scope_block(scope_frame, name = nil); end
  def scope_get(name = nil); end
  def scope_pop(name = nil); end
  def scope_push(scope_frame, name = nil); end
  def scope_reverse(name = nil, &block); end
  def scope_top(name = nil); end
end
module Tins::DynamicScope
  def dynamic_defined?(id); end
  def dynamic_scope(&block); end
  def dynamic_scope_name; end
  def dynamic_scope_name=(arg0); end
  def method_missing(id, *args); end
  include Tins::Scope
end
class Tins::DynamicScope::Context < Hash
  def [](name); end
  def []=(name, value); end
end
module Tins::CasePredicate
  def case?(*args); end
end
module Tins::Implement
  def implement(method_name, msg = nil); end
  def implement_in_submodule(method_name); end
end
module Tins::StringByteOrderMark
  def bom_encoding; end
end
module Tins::Complete
  def complete(prompt: nil, add_hist: nil, &block); end
  def self.complete(prompt: nil, add_hist: nil, &block); end
end
class Tins::Duration
  def <=>(other); end
  def days?; end
  def format(template = nil, precision: nil); end
  def format_smart; end
  def fractional_seconds?; end
  def hours?; end
  def initialize(seconds); end
  def minutes?; end
  def negative?; end
  def seconds?; end
  def to_f; end
  def to_s; end
  include Comparable
end
module Tins::Unit
  def format(value, format: nil, prefix: nil, unit: nil); end
  def parse(string, format: nil, unit: nil, prefix: nil); end
  def parse?(string, **options); end
  def prefixes(identifier); end
  def self.format(value, format: nil, prefix: nil, unit: nil); end
  def self.parse(string, format: nil, unit: nil, prefix: nil); end
  def self.parse?(string, **options); end
  def self.prefixes(identifier); end
end
class Tins::Unit::Prefix < Struct
  def fraction; end
  def fraction=(_); end
  def multiplier; end
  def multiplier=(_); end
  def name; end
  def name=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def step; end
  def step=(_); end
end
class Tins::Unit::ParserError < ArgumentError
end
class Tins::Unit::UnitParser < StringScanner
  def initialize(source, unit, prefixes = nil); end
  def number; end
  def parse; end
  def scan(re); end
  def scan_char(char); end
  def scan_number; end
  def scan_unit; end
  def unit_re(prefixes, unit); end
end
class Tins::Unit::FormatParser < StringScanner
  def initialize(format, unit_parser); end
  def location; end
  def parse; end
  def reset; end
end
module Tins::Expose
  def expose(method_name = nil, *args, &block); end
end
module Tins::TempIO
  def temp_io(content: nil, name: nil); end
end
class Tins::TempIO::Enum < Enumerator
  def initialize(chunk_size: nil, filename: nil, &content_proc); end
  include Tins::TempIO
end
