# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/glib2/all/glib2.rbi
#
# glib2-3.4.9

module GLib
  def __add_one_arg_setter(klass); end
  def check_binding_version?(major, minor, micro); end
  def exit_application(exception, status); end
  def prepend_dll_path(path); end
  def prepend_path_to_environment_variable(path, environment_name); end
  def self.__add_one_arg_setter(klass); end
  def self.application_name; end
  def self.application_name=(val); end
  def self.bit_nth_lsf(arg0, arg1); end
  def self.bit_nth_msf(arg0, arg1); end
  def self.bit_storage(arg0); end
  def self.charset; end
  def self.check_binding_version?(major, minor, micro); end
  def self.check_version?(arg0, arg1, arg2); end
  def self.convert(arg0, arg1, arg2); end
  def self.current_dir; end
  def self.exit_application(exception, status); end
  def self.filename_from_uri(arg0); end
  def self.filename_from_utf8(arg0); end
  def self.filename_to_uri(*arg0); end
  def self.filename_to_utf8(arg0); end
  def self.find_program_in_path(arg0); end
  def self.format_size(*arg0); end
  def self.format_size_for_display(*margs, &mblock); end
  def self.get_user_special_dir(arg0); end
  def self.getenv(arg0); end
  def self.home_dir; end
  def self.host_name; end
  def self.language_names; end
  def self.listenv; end
  def self.locale_from_utf8(arg0); end
  def self.locale_to_utf8(arg0); end
  def self.os_beos?; end
  def self.os_unix?; end
  def self.os_win32?; end
  def self.parse_debug_string(arg0, arg1); end
  def self.path_get_basename(arg0); end
  def self.path_get_dirname(arg0); end
  def self.path_is_absolute?(arg0); end
  def self.path_skip_root(arg0); end
  def self.prepend_dll_path(path); end
  def self.prepend_path_to_environment_variable(path, environment_name); end
  def self.prgname; end
  def self.prgname=(val); end
  def self.real_name; end
  def self.ruby_thread_priority=(val); end
  def self.set_application_name(arg0); end
  def self.set_prgname(arg0); end
  def self.set_ruby_thread_priority(arg0); end
  def self.setenv(arg0, arg1); end
  def self.spaced_primes_closest(arg0); end
  def self.system_config_dirs; end
  def self.system_data_dirs; end
  def self.tmp_dir; end
  def self.unsetenv(arg0); end
  def self.user_cache_dir; end
  def self.user_config_dir; end
  def self.user_data_dir; end
  def self.user_name; end
  def self.utf8_validate(arg0); end
  extend GLib::Deprecatable
end
module GLib::Deprecatable
  def __define_deprecated_method__(type, deprecated_method, new_method = nil, &block); end
  def const_missing(deprecated_const); end
  def define_deprecated_const(deprecated_const, new_const = nil); end
  def define_deprecated_enums(enums, prefix = nil); end
  def define_deprecated_flags(enums, prefix = nil); end
  def define_deprecated_method(deprecated_method, new_method = nil, &block); end
  def define_deprecated_method_by_hash_args(deprecated_method, old_args, new_args, req_argc = nil, &block); end
  def define_deprecated_signal(deprecated_signal, new_signal = nil); end
  def define_deprecated_singleton_method(deprecated_method, new_method = nil, &block); end
  def resolve_constant_name(name); end
  def self.extended(class_or_module); end
end
class GLib::DeprecatedError < RuntimeError
end
module GLib::GetText
  def self.bindtextdomain(*arg0); end
end
module GLib::ErrorInfo
  def code; end
  def domain; end
  def initialize(*arg0); end
end
class GLib::Thread
  def self.init; end
  def self.supported?; end
end
module GLib::Log
  def critical(str); end
  def error(str); end
  def message(str); end
  def self.always_fatal=(val); end
  def self.cancel_handler; end
  def self.critical(str); end
  def self.error(str); end
  def self.log(arg0, arg1, arg2); end
  def self.message(str); end
  def self.remove_handler(arg0, arg1); end
  def self.set_always_fatal(arg0); end
  def self.set_fatal_mask(arg0, arg1); end
  def self.set_handler(arg0, arg1); end
  def self.set_log_domain(domain); end
  def self.warning(str); end
  def set_log_domain(domain); end
  def warning(str); end
end
class GLib::Type
  def <(arg0); end
  def <=(arg0); end
  def <=>(arg0); end
  def ==(arg0); end
  def >(arg0); end
  def >=(arg0); end
  def abstract?; end
  def ancestors; end
  def children; end
  def class_size; end
  def classed?; end
  def decendants; end
  def deep_derivable?; end
  def depth; end
  def derivable?; end
  def derived?; end
  def eql?(arg0); end
  def fundamental; end
  def fundamental?; end
  def has_value_table; end
  def hash; end
  def initialize(arg0); end
  def inspect; end
  def instance_size; end
  def instantiatable?; end
  def interface?; end
  def interfaces; end
  def name; end
  def next_base(arg0); end
  def parent; end
  def self.[](*arg0); end
  def self.try_convert(arg0); end
  def to_class; end
  def to_i; end
  def to_int; end
  def to_s; end
  def type_is_a?(arg0); end
  def value_abstract?; end
  def value_type?; end
end
module GLib::MetaInterface
  def append_features(arg0); end
  def define_signal(*arg0); end
  def gtype; end
  def included(arg0); end
  def install_property(arg0); end
  def properties(*arg0); end
  def property(arg0); end
  def self.signal_callback(klass, name); end
  def signal(arg0); end
  def signal_new(*arg0); end
  def signals(*arg0); end
end
class GLib::Instantiatable
  def __deprecatable_signal_connect__(*arg0); end
  def __deprecatable_signal_connect_after__(*arg0); end
  def clone; end
  def create_signal_handler(signal_name, callback); end
  def gtype; end
  def self.method_added(name); end
  def self.signal_handler_attach(arg0, arg1); end
  def signal_connect(signal, *margs, &mblock); end
  def signal_connect_after(signal, *margs, &mblock); end
  def signal_emit(*arg0); end
  def signal_emit_stop(arg0); end
  def signal_handler_block(arg0); end
  def signal_handler_disconnect(arg0); end
  def signal_handler_is_connected?(arg0); end
  def signal_handler_unblock(arg0); end
  def signal_has_handler_pending?(*arg0); end
end
class GLib::Boxed
  def copy; end
  def gtype; end
  def initialize; end
  def initialize_copy(arg0); end
  def inspect; end
  def self.gtype; end
end
class GLib::Value < GLib::Boxed
  def initialize(*arg0); end
  def to_s; end
  def type; end
  def value; end
end
class GLib::Pointer
  def gtype(arg0); end
  def self.gtype(arg0); end
end
class GLib::Enum
  def ==(arg0); end
  def _dump(limit); end
  def coerce(arg0); end
  def eql?(arg0); end
  def gtype; end
  def hash; end
  def initialize(*arg0); end
  def inspect; end
  def name; end
  def nick; end
  def self._load(obj); end
  def self.find(arg0); end
  def self.gtype; end
  def self.range; end
  def self.try_convert(value); end
  def self.values; end
  def to_i; end
  def to_int; end
end
class GLib::Flags
  def &(arg0); end
  def -(arg0); end
  def <(arg0); end
  def <=(arg0); end
  def <=>(arg0); end
  def ==(arg0); end
  def >(arg0); end
  def >=(arg0); end
  def ^(arg0); end
  def _dump(limit); end
  def coerce(arg0); end
  def empty?; end
  def eql?(arg0); end
  def gtype; end
  def hash; end
  def initialize(*arg0); end
  def inspect; end
  def name; end
  def nick; end
  def nonzero?; end
  def self._load(obj); end
  def self.gtype; end
  def self.mask; end
  def self.try_convert(value); end
  def self.values; end
  def to_i; end
  def to_int; end
  def zero?; end
  def |(arg0); end
  def ~; end
end
class GLib::Param < GLib::Instantiatable
  def blurb; end
  def construct?; end
  def construct_only?; end
  def default; end
  def deprecated?; end
  def explicit_notify?; end
  def flags; end
  def inspect; end
  def lax_validation?; end
  def name; end
  def nick; end
  def owner; end
  def owner_type; end
  def private?(*margs, &mblock); end
  def readable?; end
  def readwrite?; end
  def ref_count; end
  def static_blurb?; end
  def static_name?; end
  def static_nick?; end
  def value_compare(arg0, arg1); end
  def value_convert(*arg0); end
  def value_default; end
  def value_type; end
  def value_validate(arg0); end
  def writable?; end
  extend GLib::Deprecatable
end
class GLib::Param::Char < GLib::Param
  def initialize(arg0, arg1, arg2, arg3, arg4, arg5, arg6); end
  def maximum; end
  def minimum; end
  def range; end
end
class GLib::Param::UChar < GLib::Param
  def initialize(arg0, arg1, arg2, arg3, arg4, arg5, arg6); end
  def maximum; end
  def minimum; end
  def range; end
end
class GLib::Param::Int < GLib::Param
  def initialize(arg0, arg1, arg2, arg3, arg4, arg5, arg6); end
  def maximum; end
  def minimum; end
  def range; end
end
class GLib::Param::UInt < GLib::Param
  def initialize(arg0, arg1, arg2, arg3, arg4, arg5, arg6); end
  def maximum; end
  def minimum; end
  def range; end
end
class GLib::Param::Long < GLib::Param
  def initialize(arg0, arg1, arg2, arg3, arg4, arg5, arg6); end
  def maximum; end
  def minimum; end
  def range; end
end
class GLib::Param::ULong < GLib::Param
  def initialize(arg0, arg1, arg2, arg3, arg4, arg5, arg6); end
  def maximum; end
  def minimum; end
  def range; end
end
class GLib::Param::Int64 < GLib::Param
  def initialize(arg0, arg1, arg2, arg3, arg4, arg5, arg6); end
  def maximum; end
  def minimum; end
  def range; end
end
class GLib::Param::UInt64 < GLib::Param
  def initialize(arg0, arg1, arg2, arg3, arg4, arg5, arg6); end
  def maximum; end
  def minimum; end
  def range; end
end
class GLib::Param::Float < GLib::Param
  def epsilon; end
  def initialize(arg0, arg1, arg2, arg3, arg4, arg5, arg6); end
  def maximum; end
  def minimum; end
  def range; end
end
class GLib::Param::Double < GLib::Param
  def epsilon; end
  def initialize(arg0, arg1, arg2, arg3, arg4, arg5, arg6); end
  def maximum; end
  def minimum; end
  def range; end
end
class GLib::Param::Boolean < GLib::Param
  def initialize(arg0, arg1, arg2, arg3, arg4); end
end
class GLib::Param::UniChar < GLib::Param
  def initialize(arg0, arg1, arg2, arg3, arg4); end
end
class GLib::Param::Enum < GLib::Param
  def initialize(arg0, arg1, arg2, arg3, arg4, arg5); end
end
class GLib::Param::Flags < GLib::Param
  def initialize(arg0, arg1, arg2, arg3, arg4, arg5); end
end
class GLib::Param::String < GLib::Param
  def initialize(arg0, arg1, arg2, arg3, arg4); end
end
class GLib::Param::Param < GLib::Param
  def initialize(arg0, arg1, arg2, arg3, arg4); end
end
class GLib::Param::Boxed < GLib::Param
  def initialize(arg0, arg1, arg2, arg3, arg4); end
end
class GLib::Param::Pointer < GLib::Param
  def initialize(arg0, arg1, arg2, arg3); end
end
class GLib::Param::Object < GLib::Param
  def initialize(arg0, arg1, arg2, arg3, arg4); end
end
class GLib::Closure < GLib::Boxed
  def in_marshal?; end
  def initialize; end
  def invalid?; end
  def invalidate; end
end
class GLib::Object < GLib::Instantiatable
  def bind_property(*arg0); end
  def destroyed?; end
  def floating?; end
  def freeze_notify; end
  def get_property(arg0); end
  def initialize(*arg0); end
  def inspect; end
  def notify(arg0); end
  def ref_count; end
  def self.install_property(*arg0); end
  def self.new!(*arg0); end
  def self.properties(*arg0); end
  def self.property(arg0); end
  def self.type_register(*arg0); end
  def set_property(arg0, arg1); end
  def thaw_notify; end
  def type_name; end
  def unref; end
end
class GLib::InitiallyUnowned < GLib::Object
end
class GLib::BindingFlags < GLib::Flags
  def bidirectional?; end
  def default?; end
  def invert_boolean?; end
  def sync_create?; end
end
class GLib::Signal
  def action?; end
  def add_emission_hook(*arg0); end
  def detailed?; end
  def flags; end
  def id; end
  def inspect; end
  def itype; end
  def name; end
  def no_hooks?; end
  def no_recurse?; end
  def owner; end
  def param_types; end
  def remove_emission_hook(arg0); end
  def return_type; end
  def run_cleanup?; end
  def run_first?; end
  def run_last?; end
end
class GLib::SignalFlags < GLib::Flags
  def action?; end
  def deprecated?; end
  def detailed?; end
  def must_collect?; end
  def no_hooks?; end
  def no_recurse?; end
  def run_cleanup?; end
  def run_first?; end
  def run_last?; end
end
class GLib::ConnectFlags < GLib::Flags
  def after?; end
  def swapped?; end
end
class GLib::SignalMatchType < GLib::Flags
  def closure?; end
  def data?; end
  def detail?; end
  def func?; end
  def id?; end
  def unblocked?; end
end
module GLib::TypePlugin
  def unuse; end
  def use; end
end
class GLib::TypeModule < GLib::Object
  def name; end
  def name=(arg0); end
  def unuse; end
  def use; end
end
class GLib::Binding < GLib::Object
  def flags; end
  def source; end
  def source_property; end
  def target; end
  def target_property; end
  def unbind; end
end
class GLib::UserDirectory < GLib::Enum
end
class GLib::FormatSizeFlags < GLib::Flags
  def bits?; end
  def default?; end
  def iec_units?; end
  def long_format?; end
end
module GLib::Spawn
  def self.async(arg0, arg1, arg2, arg3); end
  def self.async_with_pipes(arg0, arg1, arg2, arg3); end
  def self.close_pid(arg0); end
  def self.command_line_async(arg0); end
  def self.command_line_sync(arg0); end
  def self.sync(arg0, arg1, arg2, arg3); end
end
class GLib::MainLoop < GLib::Boxed
  def context; end
  def initialize(*arg0); end
  def quit; end
  def run; end
  def running?; end
end
class GLib::Source < GLib::Boxed
  def add_poll(arg0); end
  def attach(*arg0); end
  def can_recurse=(val); end
  def can_recurse?; end
  def context; end
  def destroy; end
  def destroyed?; end
  def id; end
  def name; end
  def name=(val); end
  def priority; end
  def priority=(val); end
  def ready_time; end
  def ready_time=(val); end
  def remove_poll(arg0); end
  def self.current; end
  def self.remove(arg0); end
  def set_callback; end
  def set_can_recurse(arg0); end
  def set_name(arg0); end
  def set_priority(arg0); end
  def set_ready_time(arg0); end
  def time; end
end
class GLib::MainContext < GLib::Boxed
  def acquire; end
  def add_poll(arg0, arg1); end
  def dispatch; end
  def find_source(arg0); end
  def initialize; end
  def iteration(arg0); end
  def owner?; end
  def pending?; end
  def prepare; end
  def query(arg0); end
  def release; end
  def remove_poll(arg0); end
  def self.default; end
  def self.depth; end
  def wakeup; end
end
module GLib::Timeout
  def self.add(*arg0); end
  def self.add_seconds(*arg0); end
  def self.source_new(arg0); end
  def self.source_new_seconds(arg0); end
end
module GLib::Idle
  def self.add(*arg0); end
  def self.remove(*margs, &mblock); end
  def self.source_new; end
  extend GLib::Deprecatable
end
module GLib::ChildWatch
  def self.add(arg0); end
  def self.source_new(arg0); end
end
class GLib::PollFD < GLib::Boxed
  def events; end
  def events=(val); end
  def fd; end
  def fd=(val); end
  def initialize(arg0, arg1, arg2); end
  def revents; end
  def revents=(val); end
  def set_events(arg0); end
  def set_fd(arg0); end
  def set_revents(arg0); end
end
class GLib::IOCondition < GLib::Flags
  def err?; end
  def hup?; end
  def in?; end
  def nval?; end
  def out?; end
  def pri?; end
end
class GLib::IOChannel < GLib::Boxed
  def add_watch(arg0); end
  def buffer_condition; end
  def buffer_size; end
  def buffer_size=(val); end
  def buffered; end
  def buffered=(val); end
  def close(*arg0); end
  def create_watch(*arg0); end
  def each(*arg0); end
  def each_char; end
  def each_line(*arg0); end
  def encoding; end
  def encoding=(val); end
  def fileno; end
  def flags; end
  def flags=(val); end
  def flush; end
  def getc; end
  def gets(*arg0); end
  def initialize(*arg0); end
  def pos=(val); end
  def print(*arg0); end
  def printf(*arg0); end
  def putc(arg0); end
  def puts(*arg0); end
  def read(*arg0); end
  def readchar; end
  def readline(*arg0); end
  def seek(*arg0); end
  def self.open(*arg0); end
  def set_buffer_size(arg0); end
  def set_buffered(arg0); end
  def set_encoding(arg0); end
  def set_flags(arg0); end
  def set_pos(arg0); end
  def to_i; end
  def write(arg0); end
end
module GLib::IOChannelSource
  def set_callback(*arg0); end
end
class GLib::IOChannelError < IOError
  def self.from_errno(arg0); end
end
module GLib::Shell
  def self.parse(arg0); end
  def self.quote(arg0); end
  def self.unquote(arg0); end
end
class GLib::Timer < GLib::Boxed
  def continue; end
  def elapsed; end
  def initialize; end
  def reset; end
  def start; end
  def stop; end
end
class GLib::Unicode::Type < GLib::Enum
end
class GLib::Unicode::BreakType < GLib::Enum
end
class GLib::Unicode::Script < GLib::Enum
end
class GLib::NormalizeMode < GLib::Enum
end
module GLib::Unicode
  def self.canonical_decomposition(*margs, &mblock); end
  def self.canonical_ordering(arg0); end
  extend GLib::Deprecatable
end
module GLib::UTF8
  def self.casefold(arg0); end
  def self.collate(arg0, arg1); end
  def self.collate_key(*arg0); end
  def self.downcase(arg0); end
  def self.get_char(*arg0); end
  def self.normalize(*arg0); end
  def self.reverse(arg0); end
  def self.size(arg0); end
  def self.to_ucs4(*arg0); end
  def self.to_utf16(arg0); end
  def self.upcase(arg0); end
  def self.validate(arg0); end
end
module GLib::UTF16
  def self.to_ucs4(arg0); end
  def self.to_utf8(arg0); end
end
module GLib::UCS4
  def self.to_utf16(arg0); end
  def self.to_utf8(arg0); end
end
module GLib::UniChar
  def self.alnum?(arg0); end
  def self.alpha?(arg0); end
  def self.break_type(arg0); end
  def self.cntrl?(arg0); end
  def self.combining_class(arg0); end
  def self.compose(arg0, arg1); end
  def self.decompose(*arg0); end
  def self.defined?(arg0); end
  def self.digit?(arg0); end
  def self.digit_value(arg0); end
  def self.get_mirror_char(arg0); end
  def self.get_script(arg0); end
  def self.graph?(arg0); end
  def self.lower?(arg0); end
  def self.mark?(arg0); end
  def self.print?(arg0); end
  def self.punct?(arg0); end
  def self.space?(arg0); end
  def self.title?(arg0); end
  def self.to_lower(arg0); end
  def self.to_title(arg0); end
  def self.to_upper(arg0); end
  def self.to_utf8(arg0); end
  def self.type(arg0); end
  def self.upper?(arg0); end
  def self.wide?(arg0); end
  def self.wide_cjk?(arg0); end
  def self.xdigit?(arg0); end
  def self.xdigit_value(arg0); end
  def self.zero_width?(arg0); end
end
class GLib::KeyFile < GLib::Boxed
  def get_boolean(arg0, arg1); end
  def get_boolean_list(arg0, arg1); end
  def get_comment(arg0, arg1); end
  def get_double(arg0, arg1); end
  def get_double_list(arg0, arg1); end
  def get_integer(arg0, arg1); end
  def get_integer_list(arg0, arg1); end
  def get_keys(arg0); end
  def get_locale_string(*arg0); end
  def get_locale_string_list(*arg0); end
  def get_string(arg0, arg1); end
  def get_string_list(arg0, arg1); end
  def get_value(arg0, arg1); end
  def groups; end
  def has_group?(arg0); end
  def has_key?(arg0, arg1); end
  def initialize; end
  def list_separator=(val); end
  def load_from_data(*arg0); end
  def load_from_data_dirs(*arg0); end
  def load_from_dirs(*arg0); end
  def load_from_file(*arg0); end
  def remove_comment(arg0, arg1); end
  def remove_group(arg0); end
  def remove_key(arg0, arg1); end
  def set_boolean(arg0, arg1, arg2); end
  def set_boolean_list(arg0, arg1, arg2); end
  def set_comment(arg0, arg1, arg2); end
  def set_double(arg0, arg1, arg2); end
  def set_double_list(arg0, arg1, arg2); end
  def set_integer(arg0, arg1, arg2); end
  def set_integer_list(arg0, arg1, arg2); end
  def set_list_separator(arg0); end
  def set_locale_string(arg0, arg1, arg2, arg3); end
  def set_locale_string_list(arg0, arg1, arg2, arg3); end
  def set_string(arg0, arg1, arg2); end
  def set_string_list(arg0, arg1, arg2); end
  def set_value(arg0, arg1, arg2); end
  def start_group; end
  def to_data; end
end
class GLib::KeyFile::Flags < GLib::Flags
  def keep_comments?; end
  def keep_translations?; end
  def none?; end
end
class GLib::BookmarkFile < GLib::Boxed
  def add_application(arg0, arg1, arg2); end
  def add_group(arg0, arg1); end
  def get_added(arg0); end
  def get_app_info(arg0, arg1); end
  def get_applications(arg0); end
  def get_description(arg0); end
  def get_groups(arg0); end
  def get_icon(arg0); end
  def get_mime_type(arg0); end
  def get_modified(arg0); end
  def get_title(arg0); end
  def get_visited(arg0); end
  def has_application?(arg0, arg1); end
  def has_group?(arg0, arg1); end
  def has_item?(arg0); end
  def initialize; end
  def load_from_data(arg0); end
  def load_from_data_dirs(arg0); end
  def load_from_file(arg0); end
  def move_item(arg0, arg1); end
  def private?(arg0); end
  def remove_application(arg0, arg1); end
  def remove_group(arg0, arg1); end
  def remove_item(arg0); end
  def set_added(arg0, arg1); end
  def set_app_info(arg0, arg1, arg2, arg3, arg4); end
  def set_description(arg0, arg1); end
  def set_groups(arg0, arg1); end
  def set_icon(arg0, arg1, arg2); end
  def set_mime_type(arg0, arg1); end
  def set_modified(arg0, arg1); end
  def set_private(arg0, arg1); end
  def set_title(arg0, arg1); end
  def set_visited(arg0, arg1); end
  def size; end
  def to_data; end
  def to_file(arg0); end
  def uris; end
end
class GLib::VariantType < GLib::Boxed
  def ==(arg0); end
  def array?; end
  def basic?; end
  def container?; end
  def definite?; end
  def dict_entry?; end
  def element; end
  def eql?(arg0); end
  def hash; end
  def initialize(arg0); end
  def is_subtype_of?(arg0); end
  def maybe?; end
  def self.scan(arg0); end
  def self.valid?(arg0); end
  def to_s; end
  def tuple?; end
  def variant?; end
end
class GLib::Variant < GLib::Instantiatable
  def initialize(*arg0); end
  def type; end
  def value; end
end
class GLib::Regex < GLib::Boxed
  def capture_count; end
  def compile_flags; end
  def has_cr_or_lf?; end
  def initialize(*arg0); end
  def match(*arg0); end
  def match_all(*arg0); end
  def match_flags; end
  def max_backref; end
  def max_lookbehind; end
  def pattern; end
  def replace(*arg0); end
  def self.check_replacement(arg0); end
  def self.escape_string(arg0); end
  def self.have_reference?(arg0); end
  def self.match?(pattern, string, options = nil); end
  def self.split(pattern, string, options = nil); end
  def split(*arg0); end
  def string_number(arg0); end
end
class GLib::RegexMatchFlags < GLib::Flags
  def anchored?; end
  def bsr_any?; end
  def bsr_anycrlf?; end
  def newline_any?; end
  def newline_anycrlf?; end
  def newline_cr?; end
  def newline_crlf?; end
  def newline_lf?; end
  def notbol?; end
  def notempty?; end
  def notempty_atstart?; end
  def noteol?; end
  def partial?; end
  def partial_hard?; end
  def partial_soft?; end
end
class GLib::RegexCompileFlags < GLib::Flags
  def anchored?; end
  def bsr_anycrlf?; end
  def caseless?; end
  def dollar_endonly?; end
  def dotall?; end
  def dupnames?; end
  def extended?; end
  def firstline?; end
  def javascript_compat?; end
  def multiline?; end
  def newline_anycrlf?; end
  def newline_cr?; end
  def newline_crlf?; end
  def newline_lf?; end
  def no_auto_capture?; end
  def optimize?; end
  def raw?; end
  def ungreedy?; end
end
class GLib::MatchInfo < GLib::Boxed
  def [](arg0); end
  def expand_references(arg0); end
  def fetch(arg0); end
  def fetch_all; end
  def fetch_pos(arg0); end
  def fetch_position(arg0); end
  def match_count; end
  def matches?; end
  def next; end
  def partial_match?; end
  def regex; end
  def string; end
end
class GLib::DateTime < GLib::Boxed
  def day_of_month; end
  def format(arg0); end
  def hour; end
  def initialize(*arg0); end
  def minute; end
  def month; end
  def second; end
  def self.now(*arg0); end
  def year; end
end
class GLib::TimeZone < GLib::Boxed
  def abbreviation(arg0); end
  def initialize(*arg0); end
  def offset(arg0); end
  def self.local; end
  def self.utc; end
end
class GLib::Bytes < GLib::Boxed
  def initialize(*arg0); end
  def length; end
  def pointer; end
  def self.try_convert(arg0); end
  def size; end
  def to_s; end
  def to_str; end
end
module GLib::Version
  def self.or_later?(major, minor, micro = nil); end
end
class GLib::SpawnError < IOError
  extend GLib::Deprecatable
end
module GLib::Module
end
