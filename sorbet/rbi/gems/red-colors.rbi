# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strict
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/red-colors/all/red-colors.rbi
#
# red-colors-0.3.0

module Colors
  def self.[](name); end
  def self.desaturate(c, factor); end
end
module Colors::Utils
  def linspace(x0, x1, n); end
  def make_color(value); end
  def self.linspace(x0, x1, n); end
  def self.make_color(value); end
end
module Colors::AlphaComponent
  def a; end
  def a=(a); end
  def alpha; end
  def alpha=(a); end
end
module Colors::Convert
  def closest_xterm256_gray_index(r, g, b); end
  def closest_xterm256_rgb_index(x); end
  def degree_to_radian(d); end
  def dot_product(matrix, vector); end
  def lch_to_husl(l, c, h); end
  def lch_to_luv(l, c, h); end
  def lch_to_xyz(l, c, h); end
  def linear_srgb_to_srgb(r, g, b); end
  def luminance_bounds(l); end
  def luv_to_husl(l, u, v); end
  def luv_to_lch(l, u, v); end
  def luv_to_xyz(l, u, v); end
  def matrix_inv(matrix); end
  def max_chroma(l, h); end
  def rgb_to_xterm256(r, g, b); end
  def rgb_to_xyz(r, g, b); end
  def self.closest_xterm256_gray_index(r, g, b); end
  def self.closest_xterm256_rgb_index(x); end
  def self.degree_to_radian(d); end
  def self.dot_product(matrix, vector); end
  def self.lch_to_husl(l, c, h); end
  def self.lch_to_luv(l, c, h); end
  def self.lch_to_xyz(l, c, h); end
  def self.linear_srgb_to_srgb(r, g, b); end
  def self.luminance_bounds(l); end
  def self.luv_to_husl(l, u, v); end
  def self.luv_to_lch(l, u, v); end
  def self.luv_to_xyz(l, u, v); end
  def self.matrix_inv(matrix); end
  def self.max_chroma(l, h); end
  def self.rgb_to_xterm256(r, g, b); end
  def self.rgb_to_xyz(r, g, b); end
  def self.srgb_from_linear_srgb(r, g, b); end
  def self.srgb_to_linear_srgb(r, g, b); end
  def self.xterm256_gray_index_to_code(i); end
  def self.xterm256_gray_index_to_gray_level(i); end
  def self.xterm256_rgb_index_to_rgb_value(i); end
  def self.xterm256_rgb_indices_to_code(i, j, k); end
  def self.xyy_to_xyz(x, y, large_y); end
  def self.xyz_to_rgb(x, y, z); end
  def srgb_from_linear_srgb(r, g, b); end
  def srgb_to_linear_srgb(r, g, b); end
  def xterm256_gray_index_to_code(i); end
  def xterm256_gray_index_to_gray_level(i); end
  def xterm256_rgb_index_to_rgb_value(i); end
  def xterm256_rgb_indices_to_code(i, j, k); end
  def xyy_to_xyz(x, y, large_y); end
  def xyz_to_rgb(x, y, z); end
end
module Colors::Helper
  def check_fail(exc_class, message); end
  def check_range(value, range, name); end
  def check_type(obj, type, name); end
end
class Colors::AbstractColor
  def canonicalize_component(value, name); end
  def canonicalize_component_from_integer(value, name); end
  def canonicalize_component_to_rational(value, name); end
  def desaturate(factor); end
  def inspect; end
  def unsupported(name); end
end
class Colors::HSL < Colors::AbstractColor
  def ==(other); end
  def canonicalize(h, s, l); end
  def canonicalize_from_integer(h, s, l); end
  def components; end
  def desaturate(factor); end
  def h; end
  def h=(h); end
  def hsl_components; end
  def hue; end
  def hue=(h); end
  def hue_to_rgb(t1, t2, h); end
  def initialize(h, s, l); end
  def l; end
  def l=(l); end
  def lightness; end
  def lightness=(l); end
  def rgb_components; end
  def s; end
  def s=(s); end
  def saturation; end
  def saturation=(s); end
  def to_hsl; end
  def to_hsla(alpha: nil); end
  def to_rgb; end
  def to_rgba(alpha: nil); end
  include Colors::Helper
end
class Colors::HSLA < Colors::HSL
  def ==(other); end
  def canonicalize(h, s, l, a); end
  def canonicalize_from_integer(h, s, l, a); end
  def components; end
  def desaturate(factor); end
  def hsla_components; end
  def initialize(h, s, l, a); end
  def to_hsl; end
  def to_hsla; end
  def to_rgb; end
  def to_rgba; end
  include Colors::AlphaComponent
end
class Colors::HUSL < Colors::HSL
  def ==(other); end
  def desaturate(factor); end
  def lch_components; end
  def rgb_components; end
  def to_husl; end
  def to_rgb; end
  def to_xyz; end
end
class Colors::RGB < Colors::AbstractColor
  def ==(other); end
  def b; end
  def b=(b); end
  def blue; end
  def blue=(b); end
  def canonicalize(r, g, b); end
  def canonicalize_from_integer(r, g, b); end
  def components; end
  def desaturate(factor); end
  def g; end
  def g=(g); end
  def green; end
  def green=(g); end
  def hsl_components; end
  def initialize(r, g, b); end
  def r; end
  def r=(r); end
  def red; end
  def red=(r); end
  def rgb_components; end
  def self.parse(hex_string); end
  def to_hex_string; end
  def to_hsl; end
  def to_hsla(alpha: nil); end
  def to_husl; end
  def to_rgb; end
  def to_rgba(alpha: nil); end
  def to_xterm256; end
  def to_xyz; end
  include Colors::Helper
end
class Colors::RGBA < Colors::RGB
  def ==(other); end
  def canonicalize(r, g, b, a); end
  def canonicalize_from_integer(r, g, b, a); end
  def components; end
  def desaturate(factor); end
  def initialize(r, g, b, a); end
  def self.parse(hex_string); end
  def to_hsl; end
  def to_hsla; end
  def to_rgb; end
  def to_rgba; end
  include Colors::AlphaComponent
end
class Colors::Xterm256 < Colors::AbstractColor
  def ==(other); end
  def code; end
  def initialize(code); end
  def to_grey_level; end
  def to_rgb; end
  def to_rgb_components; end
  include Colors::Helper
end
class Colors::XYY < Colors::AbstractColor
  def ==(other); end
  def canonicalize(x, y, large_y); end
  def components; end
  def initialize(x, y, large_y); end
  def large_y; end
  def luv_components(wp); end
  def rgb_components; end
  def to_rgb; end
  def to_xyz; end
  def x; end
  def y; end
  include Colors::Helper
end
class Colors::XYZ < Colors::AbstractColor
  def ==(other); end
  def canonicalize(x, y, z); end
  def components; end
  def initialize(x, y, z); end
  def luv_components(wp); end
  def rgb_components; end
  def to_rgb; end
  def uv_values; end
  def x; end
  def y; end
  def z; end
  include Colors::Helper
end
module Colors::ColorData
end
module Colors::NamedColors
  def self.[](name); end
  def self.nth_color?(name); end
end
class Colors::NamedColors::Mapping
  def [](name); end
  def []=(name, value); end
  def delete(name); end
  def initialize; end
  def lookup_no_color_cycle(name); end
  def update(other); end
end
class Colors::Colormap
  def [](x); end
  def all_ratio?(ary); end
  def html_color_block(color); end
  def init_colormap; end
  def initialize(name, n_colors); end
  def make_reverse_colormap(name); end
  def n_colors; end
  def name; end
  def over_color; end
  def over_color=(color); end
  def reversed; end
  def to_html; end
  def to_png; end
  def under_color; end
  def under_color=(color); end
  def update_extreme_colors; end
end
class Colors::ListedColormap < Colors::Colormap
  def colors; end
  def init_colormap; end
  def initialize(colors, name: nil, n_colors: nil); end
  def make_reverse_colormap(name); end
end
class Colors::LinearSegmentedColormap < Colors::Colormap
  def create_lookup_table(n, data, gamma = nil); end
  def gamma; end
  def gamma=(val); end
  def init_colormap; end
  def initialize(name, segmented_data, n_colors: nil, gamma: nil); end
  def make_inverse_func(f); end
  def make_reverse_colormap(name); end
  def segmented_data; end
  def self.new_from_list(name, colors, n_colors: nil, gamma: nil); end
end
module Colors::ColormapRegistry
  def self.[](name); end
  def self.register(cmap, name: nil, override_builtin: nil); end
  def self.unregister(name); end
end
